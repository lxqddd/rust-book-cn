<!DOCTYPE HTML>
<html lang="en" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>高级类型 - Rust编程语言</title>


        <!-- Custom HTML head -->

        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" id="highlight-css" href="highlight.css">
        <link rel="stylesheet" id="tomorrow-night-css" href="tomorrow-night.css">
        <link rel="stylesheet" id="ayu-highlight-css" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="ferris.css">
        <link rel="stylesheet" href="theme/2018-edition.css">
        <link rel="stylesheet" href="theme/semantic-notes.css">
        <link rel="stylesheet" href="theme/listing.css">


        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="toc.js"></script>
    </head>
    <body>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var sidebar = null;
            var sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Rust编程语言</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/lxqddd/rust-book-cn" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h2 id="高级类型"><a class="header" href="#高级类型">高级类型</a></h2>
<p>Rust 的类型系统有一些我们之前提到但尚未讨论的特性。我们将从讨论 newtype 模式开始，探讨为什么 newtype 作为类型是有用的。然后我们将转向类型别名，这是一个与 newtype 类似但语义略有不同的特性。我们还将讨论 <code>!</code> 类型和动态大小类型。</p>
<h3 id="使用-newtype-模式实现类型安全和抽象"><a class="header" href="#使用-newtype-模式实现类型安全和抽象">使用 Newtype 模式实现类型安全和抽象</a></h3>
<p>本节假设你已经阅读了前面的章节 <a href="ch20-02-advanced-traits.html#using-the-newtype-pattern-to-implement-external-traits-on-external-types">“使用 Newtype 模式在外部类型上实现外部特性。”</a><!-- ignore --> newtype 模式在我们目前讨论的任务之外也非常有用，包括静态地确保值永远不会混淆，并指示值的单位。你在 Listing 20-16 中看到了使用 newtype 来指示单位的示例：回想一下，<code>Millimeters</code> 和 <code>Meters</code> 结构体将 <code>u32</code> 值包装在 newtype 中。如果我们编写一个参数类型为 <code>Millimeters</code> 的函数，我们将无法编译一个意外地尝试使用 <code>Meters</code> 类型的值或普通的 <code>u32</code> 值调用该函数的程序。</p>
<p>我们还可以使用 newtype 模式来抽象掉类型的某些实现细节：新类型可以公开一个与私有内部类型的 API 不同的公共 API。</p>
<p>Newtype 还可以隐藏内部实现。例如，我们可以提供一个 <code>People</code> 类型来包装一个 <code>HashMap&lt;i32, String&gt;</code>，它存储与名称相关联的人的 ID。使用 <code>People</code> 的代码只会与我们提供的公共 API 交互，例如向 <code>People</code> 集合添加名称字符串的方法；该代码不需要知道我们在内部为名称分配了一个 <code>i32</code> ID。newtype 模式是一种轻量级的方式来实现封装以隐藏实现细节，我们在第 18 章的 <a href="ch18-01-what-is-oo.html#encapsulation-that-hides-implementation-details">“隐藏实现细节的封装”</a><!-- ignore --> 中讨论过。</p>
<h3 id="使用类型别名创建类型同义词"><a class="header" href="#使用类型别名创建类型同义词">使用类型别名创建类型同义词</a></h3>
<p>Rust 提供了声明 <em>类型别名</em> 的能力，以便为现有类型提供另一个名称。为此，我们使用 <code>type</code> 关键字。例如，我们可以创建别名 <code>Kilometers</code> 为 <code>i32</code>，如下所示：</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">fn main() {
</span>    type Kilometers = i32;
<span class="boring">
</span><span class="boring">    let x: i32 = 5;
</span><span class="boring">    let y: Kilometers = 5;
</span><span class="boring">
</span><span class="boring">    println!("x + y = {}", x + y);
</span><span class="boring">}</span></code></pre></pre>
<p>现在，别名 <code>Kilometers</code> 是 <code>i32</code> 的 <em>同义词</em>；与我们在 Listing 20-16 中创建的 <code>Millimeters</code> 和 <code>Meters</code> 类型不同，<code>Kilometers</code> 不是一个单独的、新的类型。具有 <code>Kilometers</code> 类型的值将与 <code>i32</code> 类型的值相同对待：</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">fn main() {
</span>    type Kilometers = i32;

    let x: i32 = 5;
    let y: Kilometers = 5;

    println!("x + y = {}", x + y);
<span class="boring">}</span></code></pre></pre>
<p>因为 <code>Kilometers</code> 和 <code>i32</code> 是相同的类型，我们可以将这两种类型的值相加，并且我们可以将 <code>Kilometers</code> 值传递给接受 <code>i32</code> 参数的函数。然而，使用这种方法，我们不会得到之前讨论的 newtype 模式所带来的类型检查的好处。换句话说，如果我们在某处混淆了 <code>Kilometers</code> 和 <code>i32</code> 值，编译器不会给我们错误。</p>
<p>类型同义词的主要用例是减少重复。例如，我们可能有一个冗长的类型，如下所示：</p>
<pre><code class="language-rust ignore">Box&lt;dyn Fn() + Send + 'static&gt;</code></pre>
<p>在函数签名和代码中的类型注释中到处写这个冗长的类型可能会很繁琐且容易出错。想象一下，有一个项目充满了像 Listing 20-25 中的代码。</p>
<figure class="listing">
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">fn main() {
</span>    let f: Box&lt;dyn Fn() + Send + 'static&gt; = Box::new(|| println!("hi"));

    fn takes_long_type(f: Box&lt;dyn Fn() + Send + 'static&gt;) {
        // --snip--
    }

    fn returns_long_type() -&gt; Box&lt;dyn Fn() + Send + 'static&gt; {
        // --snip--
<span class="boring">        Box::new(|| ())
</span>    }
<span class="boring">}</span></code></pre></pre>
<figcaption>Listing 20-25: 在许多地方使用长类型</figcaption>
</figure>
<p>类型别名通过减少重复使代码更易于管理。在 Listing 20-26 中，我们为冗长的类型引入了一个名为 <code>Thunk</code> 的别名，并可以用较短的别名 <code>Thunk</code> 替换所有使用该类型的地方。</p>
<figure class="listing">
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">fn main() {
</span>    type Thunk = Box&lt;dyn Fn() + Send + 'static&gt;;

    let f: Thunk = Box::new(|| println!("hi"));

    fn takes_long_type(f: Thunk) {
        // --snip--
    }

    fn returns_long_type() -&gt; Thunk {
        // --snip--
<span class="boring">        Box::new(|| ())
</span>    }
<span class="boring">}</span></code></pre></pre>
<figcaption>Listing 20-26: 引入类型别名 <code>Thunk</code> 以减少重复</figcaption>
</figure>
<p>这段代码更容易阅读和编写！为类型别名选择一个有意义的名称可以帮助传达你的意图（<em>thunk</em> 是一个稍后评估的代码的词，因此它是一个存储闭包的合适名称）。</p>
<p>类型别名也常用于 <code>Result&lt;T, E&gt;</code> 类型以减少重复。考虑标准库中的 <code>std::io</code> 模块。I/O 操作通常返回一个 <code>Result&lt;T, E&gt;</code> 来处理操作失败的情况。这个库有一个 <code>std::io::Error</code> 结构体，表示所有可能的 I/O 错误。<code>std::io</code> 中的许多函数将返回 <code>Result&lt;T, E&gt;</code>，其中 <code>E</code> 是 <code>std::io::Error</code>，例如 <code>Write</code> 特性中的这些函数：</p>
<pre><code class="language-rust noplayground">use std::fmt;
use std::io::Error;

pub trait Write {
    fn write(&amp;mut self, buf: &amp;[u8]) -&gt; Result&lt;usize, Error&gt;;
    fn flush(&amp;mut self) -&gt; Result&lt;(), Error&gt;;

    fn write_all(&amp;mut self, buf: &amp;[u8]) -&gt; Result&lt;(), Error&gt;;
    fn write_fmt(&amp;mut self, fmt: fmt::Arguments) -&gt; Result&lt;(), Error&gt;;
}</code></pre>
<p><code>Result&lt;..., Error&gt;</code> 重复了很多次。因此，<code>std::io</code> 有这个类型别名声明：</p>
<pre><code class="language-rust noplayground"><span class="boring">use std::fmt;
</span><span class="boring">
</span>type Result&lt;T&gt; = std::result::Result&lt;T, std::io::Error&gt;;
<span class="boring">
</span><span class="boring">pub trait Write {
</span><span class="boring">    fn write(&amp;mut self, buf: &amp;[u8]) -&gt; Result&lt;usize&gt;;
</span><span class="boring">    fn flush(&amp;mut self) -&gt; Result&lt;()&gt;;
</span><span class="boring">
</span><span class="boring">    fn write_all(&amp;mut self, buf: &amp;[u8]) -&gt; Result&lt;()&gt;;
</span><span class="boring">    fn write_fmt(&amp;mut self, fmt: fmt::Arguments) -&gt; Result&lt;()&gt;;
</span><span class="boring">}</span></code></pre>
<p>因为这个声明在 <code>std::io</code> 模块中，我们可以使用完全限定的别名 <code>std::io::Result&lt;T&gt;</code>；也就是说，一个 <code>Result&lt;T, E&gt;</code>，其中 <code>E</code> 被填充为 <code>std::io::Error</code>。<code>Write</code> 特性的函数签名最终看起来像这样：</p>
<pre><code class="language-rust noplayground"><span class="boring">use std::fmt;
</span><span class="boring">
</span><span class="boring">type Result&lt;T&gt; = std::result::Result&lt;T, std::io::Error&gt;;
</span><span class="boring">
</span>pub trait Write {
    fn write(&amp;mut self, buf: &amp;[u8]) -&gt; Result&lt;usize&gt;;
    fn flush(&amp;mut self) -&gt; Result&lt;()&gt;;

    fn write_all(&amp;mut self, buf: &amp;[u8]) -&gt; Result&lt;()&gt;;
    fn write_fmt(&amp;mut self, fmt: fmt::Arguments) -&gt; Result&lt;()&gt;;
}</code></pre>
<p>类型别名在两个方面有帮助：它使代码更容易编写 <em>并且</em> 它为我们提供了一个跨所有 <code>std::io</code> 的一致接口。因为它是一个别名，它只是另一个 <code>Result&lt;T, E&gt;</code>，这意味着我们可以使用任何适用于 <code>Result&lt;T, E&gt;</code> 的方法，以及像 <code>?</code> 操作符这样的特殊语法。</p>
<h3 id="永不返回的-never-类型"><a class="header" href="#永不返回的-never-类型">永不返回的 Never 类型</a></h3>
<p>Rust 有一个名为 <code>!</code> 的特殊类型，在类型理论术语中称为 <em>空类型</em>，因为它没有值。我们更喜欢称它为 <em>never 类型</em>，因为它在函数永远不会返回时代表返回类型。以下是一个示例：</p>
<pre><code class="language-rust noplayground">fn bar() -&gt; ! {
    // --snip--
<span class="boring">    panic!();
</span>}</code></pre>
<p>这段代码被解读为“函数 <code>bar</code> 返回 never。”返回 never 的函数称为 <em>发散函数</em>。我们无法创建 <code>!</code> 类型的值，因此 <code>bar</code> 永远不可能返回。</p>
<p>但是，一个你永远无法创建值的类型有什么用呢？回想一下 Listing 2-5 中的代码，数字猜谜游戏的一部分；我们在 Listing 20-27 中重现了其中的一部分。</p>
<figure class="listing">
<pre><code class="language-rust ignore"><span class="boring">use rand::Rng;
</span><span class="boring">use std::cmp::Ordering;
</span><span class="boring">use std::io;
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    println!("Guess the number!");
</span><span class="boring">
</span><span class="boring">    let secret_number = rand::thread_rng().gen_range(1..=100);
</span><span class="boring">
</span><span class="boring">    println!("The secret number is: {secret_number}");
</span><span class="boring">
</span><span class="boring">    loop {
</span><span class="boring">        println!("Please input your guess.");
</span><span class="boring">
</span><span class="boring">        let mut guess = String::new();
</span><span class="boring">
</span><span class="boring">        // --snip--
</span><span class="boring">
</span><span class="boring">        io::stdin()
</span><span class="boring">            .read_line(&amp;mut guess)
</span><span class="boring">            .expect("Failed to read line");
</span><span class="boring">
</span>        let guess: u32 = match guess.trim().parse() {
            Ok(num) =&gt; num,
            Err(_) =&gt; continue,
        };
<span class="boring">
</span><span class="boring">        println!("You guessed: {guess}");
</span><span class="boring">
</span><span class="boring">        // --snip--
</span><span class="boring">
</span><span class="boring">        match guess.cmp(&amp;secret_number) {
</span><span class="boring">            Ordering::Less =&gt; println!("Too small!"),
</span><span class="boring">            Ordering::Greater =&gt; println!("Too big!"),
</span><span class="boring">            Ordering::Equal =&gt; {
</span><span class="boring">                println!("You win!");
</span><span class="boring">                break;
</span><span class="boring">            }
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">}</span></code></pre>
<figcaption>Listing 20-27: 一个以 <code>continue</code> 结尾的 <code>match</code> 分支</figcaption>
</figure>
<p>当时，我们跳过了这段代码中的一些细节。在第 6 章的 <a href="ch06-02-match.html#the-match-control-flow-operator">“<code>match</code> 控制流操作符”</a><!-- ignore --> 中，我们讨论了 <code>match</code> 分支必须都返回相同的类型。因此，例如，以下代码不起作用：</p>
<pre><code class="language-rust ignore does_not_compile"><span class="boring">fn main() {
</span><span class="boring">    let guess = "3";
</span>    let guess = match guess.trim().parse() {
        Ok(_) =&gt; 5,
        Err(_) =&gt; "hello",
    };
<span class="boring">}</span></code></pre>
<p>这段代码中的 <code>guess</code> 类型必须是一个整数 <em>和</em> 一个字符串，而 Rust 要求 <code>guess</code> 只有一个类型。那么 <code>continue</code> 返回什么？我们如何在 Listing 20-27 中从一个分支返回 <code>u32</code> 并让另一个分支以 <code>continue</code> 结尾？</p>
<p>正如你可能已经猜到的，<code>continue</code> 有一个 <code>!</code> 值。也就是说，当 Rust 计算 <code>guess</code> 的类型时，它会查看两个 <code>match</code> 分支，前者有一个 <code>u32</code> 值，后者有一个 <code>!</code> 值。因为 <code>!</code> 永远不会有值，Rust 决定 <code>guess</code> 的类型是 <code>u32</code>。</p>
<p>描述这种行为的形式化方式是，类型为 <code>!</code> 的表达式可以被强制转换为任何其他类型。我们被允许以 <code>continue</code> 结束这个 <code>match</code> 分支，因为 <code>continue</code> 不会返回值；相反，它将控制权移回循环的顶部，因此在 <code>Err</code> 情况下，我们永远不会为 <code>guess</code> 赋值。</p>
<p>never 类型与 <code>panic!</code> 宏也很有用。回想一下我们在 <code>Option&lt;T&gt;</code> 值上调用的 <code>unwrap</code> 函数，以生成一个值或 panic，其定义如下：</p>
<pre><code class="language-rust ignore"><span class="boring">enum Option&lt;T&gt; {
</span><span class="boring">    Some(T),
</span><span class="boring">    None,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">use crate::Option::*;
</span><span class="boring">
</span>impl&lt;T&gt; Option&lt;T&gt; {
    pub fn unwrap(self) -&gt; T {
        match self {
            Some(val) =&gt; val,
            None =&gt; panic!("called `Option::unwrap()` on a `None` value"),
        }
    }
}</code></pre>
<p>在这段代码中，发生了与 Listing 20-27 中的 <code>match</code> 相同的事情：Rust 看到 <code>val</code> 的类型是 <code>T</code>，而 <code>panic!</code> 的类型是 <code>!</code>，因此整个 <code>match</code> 表达式的结果是 <code>T</code>。这段代码有效是因为 <code>panic!</code> 不会产生值；它结束了程序。在 <code>None</code> 情况下，我们不会从 <code>unwrap</code> 返回值，因此这段代码是有效的。</p>
<p>最后一个具有 <code>!</code> 类型的表达式是 <code>loop</code>：</p>
<pre><code class="language-rust ignore"><span class="boring">fn main() {
</span>    print!("forever ");

    loop {
        print!("and ever ");
    }
<span class="boring">}</span></code></pre>
<p>在这里，循环永远不会结束，因此 <code>!</code> 是表达式的值。然而，如果我们包含一个 <code>break</code>，这将不再成立，因为循环将在到达 <code>break</code> 时终止。</p>
<h3 id="动态大小类型和-sized-特性"><a class="header" href="#动态大小类型和-sized-特性">动态大小类型和 <code>Sized</code> 特性</a></h3>
<p>Rust 需要知道其类型的某些细节，例如为特定类型的值分配多少空间。这使得其类型系统的一个角落在一开始有点令人困惑：<em>动态大小类型</em> 的概念。有时称为 <em>DSTs</em> 或 <em>未大小类型</em>，这些类型让我们可以编写使用值的代码，这些值的大小我们只能在运行时知道。</p>
<p>让我们深入了解一个名为 <code>str</code> 的动态大小类型的细节，我们在整本书中一直在使用它。没错，不是 <code>&amp;str</code>，而是 <code>str</code> 本身，是一个 DST。我们无法知道字符串的长度直到运行时，这意味着我们无法创建类型为 <code>str</code> 的变量，也无法接受类型为 <code>str</code> 的参数。考虑以下代码，它不起作用：</p>
<pre><code class="language-rust ignore does_not_compile"><span class="boring">fn main() {
</span>    let s1: str = "Hello there!";
    let s2: str = "How's it going?";
<span class="boring">}</span></code></pre>
<p>Rust 需要知道为特定类型的任何值分配多少内存，并且一个类型的所有值必须使用相同数量的内存。如果 Rust 允许我们编写这段代码，这两个 <code>str</code> 值将需要占用相同数量的空间。但它们有不同的长度：<code>s1</code> 需要 12 字节的存储空间，而 <code>s2</code> 需要 15 字节。这就是为什么不可能创建一个持有动态大小类型的变量。</p>
<p>那么我们该怎么办？在这种情况下，你已经知道答案：我们将 <code>s1</code> 和 <code>s2</code> 的类型改为 <code>&amp;str</code> 而不是 <code>str</code>。回想一下第 4 章的 <a href="ch04-03-slices.html#string-slices">“字符串切片”</a><!-- ignore -->，切片数据结构只存储切片的起始位置和长度。因此，尽管 <code>&amp;T</code> 是一个存储 <code>T</code> 所在内存地址的单个值，<code>&amp;str</code> 是 <em>两个</em> 值：<code>str</code> 的地址和它的长度。因此，我们可以在编译时知道 <code>&amp;str</code> 值的大小：它是 <code>usize</code> 长度的两倍。也就是说，我们总是知道 <code>&amp;str</code> 的大小，无论它引用的字符串有多长。一般来说，这是在 Rust 中使用动态大小类型的方式：它们有一个额外的元数据位，用于存储动态信息的大小。动态大小类型的黄金法则是，我们必须始终将动态大小类型的值放在某种指针后面。</p>
<p>我们可以将 <code>str</code> 与各种指针结合使用：例如，<code>Box&lt;str&gt;</code> 或 <code>Rc&lt;str&gt;</code>。事实上，你以前见过这个，但使用了一个不同的动态大小类型：特性。每个特性都是一个动态大小类型，我们可以通过使用特性的名称来引用它。在第 18 章的 <a href="ch18-02-trait-objects.html#using-trait-objects-that-allow-for-values-of-different-types">“使用允许不同类型值的特性对象”</a><!-- ignore --> 中，我们提到要使用特性作为特性对象，我们必须将它们放在指针后面，例如 <code>&amp;dyn Trait</code> 或 <code>Box&lt;dyn Trait&gt;</code>（<code>Rc&lt;dyn Trait&gt;</code> 也可以工作）。</p>
<p>为了处理动态大小类型（DSTs），Rust 提供了 <code>Sized</code> trait 来确定一个类型的大小是否在编译时已知。这个 trait 会自动为所有在编译时已知大小的类型实现。此外，Rust 隐式地为每个泛型函数添加了 <code>Sized</code> 的约束。也就是说，像这样的泛型函数定义：</p>
<pre><code class="language-rust ignore">fn generic&lt;T&gt;(t: T) {
    // --snip--
}</code></pre>
<p>实际上会被视为我们写了这样的代码：</p>
<pre><code class="language-rust ignore">fn generic&lt;T: Sized&gt;(t: T) {
    // --snip--
}</code></pre>
<p>默认情况下，泛型函数只会作用于那些在编译时已知大小的类型。然而，你可以使用以下特殊语法来放宽这个限制：</p>
<pre><code class="language-rust ignore">fn generic&lt;T: ?Sized&gt;(t: &amp;T) {
    // --snip--
}</code></pre>
<p><code>?Sized</code> 的 trait 约束意味着“<code>T</code> 可能是 <code>Sized</code>，也可能不是 <code>Sized</code>”，这种表示法覆盖了泛型类型必须在编译时已知大小的默认行为。这种含义的 <code>?Trait</code> 语法仅适用于 <code>Sized</code>，不适用于其他 trait。</p>
<p>还要注意，我们将 <code>t</code> 参数的类型从 <code>T</code> 切换为 <code>&amp;T</code>。因为类型可能不是 <code>Sized</code>，我们需要在某种指针后面使用它。在这种情况下，我们选择了引用。</p>
<p>接下来，我们将讨论函数和闭包！</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="ch20-02-advanced-traits.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="ch20-04-advanced-functions-and-closures.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="ch20-02-advanced-traits.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="ch20-04-advanced-functions-and-closures.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->
        <script src="ferris.js"></script>


    </div>
    </body>
</html>
