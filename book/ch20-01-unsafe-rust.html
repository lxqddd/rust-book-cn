<!DOCTYPE HTML>
<html lang="en" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>不安全的 Rust - Rust编程语言</title>


        <!-- Custom HTML head -->

        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" id="highlight-css" href="highlight.css">
        <link rel="stylesheet" id="tomorrow-night-css" href="tomorrow-night.css">
        <link rel="stylesheet" id="ayu-highlight-css" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="ferris.css">
        <link rel="stylesheet" href="theme/2018-edition.css">
        <link rel="stylesheet" href="theme/semantic-notes.css">
        <link rel="stylesheet" href="theme/listing.css">


        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="toc.js"></script>
    </head>
    <body>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var sidebar = null;
            var sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Rust编程语言</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/lxqddd/rust-book-cn" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h2 id="不安全的-rust"><a class="header" href="#不安全的-rust">不安全的 Rust</a></h2>
<p>到目前为止，我们讨论的所有代码都在编译时强制执行了 Rust 的内存安全保证。然而，Rust 内部还隐藏着另一种语言，它不强制执行这些内存安全保证：它被称为<strong>不安全的 Rust</strong>，其工作方式与常规 Rust 一样，但为我们提供了额外的超能力。</p>
<p>不安全的 Rust 存在的原因是，静态分析本质上是保守的。当编译器试图确定代码是否遵守这些保证时，拒绝一些有效的程序比接受一些无效的程序更好。尽管代码<strong>可能</strong>没问题，但如果 Rust 编译器没有足够的信息来确信，它就会拒绝该代码。在这种情况下，你可以使用不安全的代码来告诉编译器：“相信我，我知道我在做什么。”不过要注意，使用不安全的 Rust 是有风险的：如果你不正确使用不安全的代码，可能会因为内存不安全而出现问题，例如空指针解引用。</p>
<p>Rust 有不安全的另一面的另一个原因是，底层的计算机硬件本质上就是不安全的。如果 Rust 不允许你进行不安全的操作，你将无法完成某些任务。Rust 需要允许你进行低级系统编程，例如直接与操作系统交互，甚至编写自己的操作系统。进行低级系统编程是该语言的目标之一。让我们来探索一下我们可以用不安全的 Rust 做什么以及如何做。</p>
<h3 id="不安全的超能力"><a class="header" href="#不安全的超能力">不安全的超能力</a></h3>
<p>要切换到不安全的 Rust，请使用 <code>unsafe</code> 关键字，然后开始一个新的代码块，其中包含不安全的代码。你可以在不安全的 Rust 中执行五个操作，这些操作在安全的 Rust 中是不允许的，我们称之为<strong>不安全的超能力</strong>。这些超能力包括：</p>
<ul>
<li>解引用裸指针</li>
<li>调用不安全的函数或方法</li>
<li>访问或修改可变的静态变量</li>
<li>实现不安全的 trait</li>
<li>访问 <code>union</code> 的字段</li>
</ul>
<p>重要的是要理解，<code>unsafe</code> 并不会关闭借用检查器或禁用 Rust 的其他安全检查：如果你在不安全的代码中使用引用，它仍然会被检查。<code>unsafe</code> 关键字只是让你能够访问这五个特性，然后编译器不会对这些特性进行内存安全检查。在不安全的代码块中，你仍然会获得一定程度的安全性。</p>
<p>此外，<code>unsafe</code> 并不意味着代码块中的代码必然危险或一定会出现内存安全问题：其意图是作为程序员，你将确保 <code>unsafe</code> 块中的代码以有效的方式访问内存。</p>
<p>人都会犯错，错误也会发生，但通过要求这五个不安全的操作必须在标记为 <code>unsafe</code> 的块中执行，你将知道任何与内存安全相关的错误都必须出现在 <code>unsafe</code> 块中。保持 <code>unsafe</code> 块尽可能小；当你调查内存错误时，你会感激这一点。</p>
<p>为了尽可能隔离不安全的代码，最好将这些代码封装在一个安全的抽象中，并提供一个安全的 API，我们将在本章后面讨论不安全的函数和方法时探讨这一点。标准库的部分内容是通过对经过审计的不安全代码进行安全抽象来实现的。将不安全的代码封装在安全抽象中可以防止 <code>unsafe</code> 的使用泄漏到所有你可能希望使用 <code>unsafe</code> 代码实现功能的地方，因为使用安全抽象是安全的。</p>
<p>让我们依次看看这五个不安全的超能力。我们还将探讨一些为不安全代码提供安全接口的抽象。</p>
<h3 id="解引用裸指针"><a class="header" href="#解引用裸指针">解引用裸指针</a></h3>
<p>在第 4 章的<a href="ch04-02-references-and-borrowing.html#dangling-references">“悬垂引用”</a><!-- ignore -->中，我们提到编译器确保引用始终有效。不安全的 Rust 有两个新类型，称为<strong>裸指针</strong>，它们类似于引用。与引用一样，裸指针可以是不可变的或可变的，分别写为 <code>*const T</code> 和 <code>*mut T</code>。星号不是解引用操作符；它是类型名称的一部分。在裸指针的上下文中，<strong>不可变</strong>意味着指针在解引用后不能直接赋值。</p>
<p>与引用和智能指针不同，裸指针：</p>
<ul>
<li>允许忽略借用规则，可以同时拥有不可变和可变指针，或多个可变指针指向同一位置</li>
<li>不保证指向有效的内存</li>
<li>允许为空</li>
<li>不实现任何自动清理</li>
</ul>
<p>通过选择不让 Rust 强制执行这些保证，你可以放弃有保证的安全性，以换取更高的性能或与 Rust 的保证不适用的其他语言或硬件进行交互的能力。</p>
<p>Listing 20-1 展示了如何创建一个不可变和一个可变的裸指针。</p>
<figure class="listing">
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">fn main() {
</span>    let mut num = 5;

    let r1 = &amp;raw const num;
    let r2 = &amp;raw mut num;
<span class="boring">}</span></code></pre></pre>
<figcaption>Listing 20-1: 使用裸借用操作符创建裸指针</figcaption>
</figure>
<p>注意，我们在这个代码中没有包含 <code>unsafe</code> 关键字。我们可以在安全代码中创建裸指针；只是不能在 <code>unsafe</code> 块之外解引用裸指针，稍后你会看到。</p>
<p>我们使用裸借用操作符创建了裸指针：<code>&amp;raw const num</code> 创建了一个 <code>*const i32</code> 不可变裸指针，<code>&amp;raw mut num</code> 创建了一个 <code>*mut i32</code> 可变裸指针。因为我们直接从局部变量创建它们，所以我们知道这些特定的裸指针是有效的，但我们不能对任何裸指针都做出这种假设。</p>
<p>为了演示这一点，接下来我们将创建一个裸指针，其有效性我们无法确定，使用 <code>as</code> 来转换值而不是使用裸借用操作符。Listing 20-2 展示了如何创建一个指向内存中任意位置的裸指针。尝试使用任意内存是未定义的：该地址可能有数据，也可能没有，编译器可能会优化代码，使其不访问内存，或者程序可能会因段错误而终止。通常，没有好的理由编写这样的代码，尤其是在可以使用裸借用操作符的情况下，但这是可能的。</p>
<figure class="listing">
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">fn main() {
</span>    let address = 0x012345usize;
    let r = address as *const i32;
<span class="boring">}</span></code></pre></pre>
<figcaption>Listing 20-2: 创建一个指向任意内存地址的裸指针</figcaption>
</figure>
<p>回想一下，我们可以在安全代码中创建裸指针，但我们不能<strong>解引用</strong>裸指针并读取指向的数据。在 Listing 20-3 中，我们在需要 <code>unsafe</code> 块的裸指针上使用解引用操作符 <code>*</code>。</p>
<figure class="listing">
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">fn main() {
</span>    let mut num = 5;

    let r1 = &amp;raw const num;
    let r2 = &amp;raw mut num;

    unsafe {
        println!("r1 is: {}", *r1);
        println!("r2 is: {}", *r2);
    }
<span class="boring">}</span></code></pre></pre>
<figcaption>Listing 20-3: 在 <code>unsafe</code> 块中解引用裸指针</figcaption>
</figure>
<p>创建指针不会造成任何伤害；只有当我们尝试访问它指向的值时，我们才可能会处理一个无效的值。</p>
<p>还要注意，在 Listing 20-1 和 20-3 中，我们创建了 <code>*const i32</code> 和 <code>*mut i32</code> 裸指针，它们都指向存储 <code>num</code> 的同一内存位置。如果我们尝试创建对 <code>num</code> 的不可变和可变引用，代码将无法编译，因为 Rust 的所有权规则不允许在存在不可变引用的同时存在可变引用。使用裸指针，我们可以创建一个可变指针和一个不可变指针指向同一位置，并通过可变指针更改数据，这可能会导致数据竞争。要小心！</p>
<p>既然有这么多危险，为什么还要使用裸指针呢？一个主要的用例是与 C 代码交互，你将在下一节<a href="#calling-an-unsafe-function-or-method">“调用不安全的函数或方法”</a><!-- ignore -->中看到。另一个用例是构建借用检查器无法理解的安全抽象。我们将介绍不安全的函数，然后看一个使用不安全代码的安全抽象示例。</p>
<h3 id="调用不安全的函数或方法"><a class="header" href="#调用不安全的函数或方法">调用不安全的函数或方法</a></h3>
<p>你可以在不安全的块中执行的第二种操作是调用不安全的函数。不安全的函数和方法看起来与常规函数和方法完全一样，但它们在定义前多了一个 <code>unsafe</code>。在这个上下文中，<code>unsafe</code> 关键字表示该函数有一些我们在调用时需要遵守的要求，因为 Rust 无法保证我们已经满足这些要求。通过在 <code>unsafe</code> 块中调用不安全的函数，我们表示我们已经阅读了该函数的文档，并承担了遵守函数契约的责任。</p>
<p>这里有一个名为 <code>dangerous</code> 的不安全函数，它的函数体中没有做任何事情：</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">fn main() {
</span>    unsafe fn dangerous() {}

    unsafe {
        dangerous();
    }
<span class="boring">}</span></code></pre></pre>
<p>我们必须在单独的 <code>unsafe</code> 块中调用 <code>dangerous</code> 函数。如果我们尝试在没有 <code>unsafe</code> 块的情况下调用 <code>dangerous</code>，我们会得到一个错误：</p>
<pre><code class="language-console">$ cargo run
   Compiling unsafe-example v0.1.0 (file:///projects/unsafe-example)
error[E0133]: call to unsafe function `dangerous` is unsafe and requires unsafe block
 --&gt; src/main.rs:4:5
  |
4 |     dangerous();
  |     ^^^^^^^^^^^ call to unsafe function
  |
  = note: consult the function's documentation for information on how to avoid undefined behavior

For more information about this error, try `rustc --explain E0133`.
error: could not compile `unsafe-example` (bin "unsafe-example") due to 1 previous error
</code></pre>
<p>使用 <code>unsafe</code> 块，我们向 Rust 断言我们已经阅读了函数的文档，理解了如何正确使用它，并验证了我们正在履行函数的契约。</p>
<p>要在不安全函数的函数体中执行不安全的操作，你仍然需要使用 <code>unsafe</code> 块，就像在常规函数中一样，如果你忘记了，编译器会警告你。这有助于保持 <code>unsafe</code> 块尽可能小，因为可能不需要在整个函数体中都使用不安全的操作。</p>
<h4 id="在不安全代码上创建安全抽象"><a class="header" href="#在不安全代码上创建安全抽象">在不安全代码上创建安全抽象</a></h4>
<p>仅仅因为一个函数包含不安全的代码并不意味着我们需要将整个函数标记为不安全的。事实上，将不安全的代码封装在安全函数中是一种常见的抽象。作为一个例子，让我们研究一下标准库中的 <code>split_at_mut</code> 函数，它需要一些不安全的代码。我们将探讨如何实现它。这个安全方法定义在可变切片上：它接受一个切片，并通过在给定的索引处拆分切片将其分成两个。Listing 20-4 展示了如何使用 <code>split_at_mut</code>。</p>
<figure class="listing">
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">fn main() {
</span>    let mut v = vec![1, 2, 3, 4, 5, 6];

    let r = &amp;mut v[..];

    let (a, b) = r.split_at_mut(3);

    assert_eq!(a, &amp;mut [1, 2, 3]);
    assert_eq!(b, &amp;mut [4, 5, 6]);
<span class="boring">}</span></code></pre></pre>
<figcaption>Listing 20-4: 使用安全的 <code>split_at_mut</code> 函数</figcaption>
</figure>
<p>我们不能仅使用安全的 Rust 实现这个函数。尝试可能看起来像 Listing 20-5，但它不会编译。为了简单起见，我们将 <code>split_at_mut</code> 实现为一个函数而不是方法，并且只针对 <code>i32</code> 值的切片而不是泛型类型 <code>T</code>。</p>
<figure class="listing">
<pre><code class="language-rust ignore does_not_compile">fn split_at_mut(values: &amp;mut [i32], mid: usize) -&gt; (&amp;mut [i32], &amp;mut [i32]) {
    let len = values.len();

    assert!(mid &lt;= len);

    (&amp;mut values[..mid], &amp;mut values[mid..])
}
<span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    let mut vector = vec![1, 2, 3, 4, 5, 6];
</span><span class="boring">    let (left, right) = split_at_mut(&amp;mut vector, 3);
</span><span class="boring">}</span></code></pre>
<figcaption>Listing 20-5: 尝试仅使用安全的 Rust 实现 <code>split_at_mut</code></figcaption>
</figure>
<p>这个函数首先获取切片的长度。然后它通过检查给定的索引是否小于或等于长度来断言该索引在切片内。这个断言意味着如果我们传递一个大于长度的索引来拆分切片，函数将在尝试使用该索引之前 panic。</p>
<p>然后我们返回一个元组中的两个可变切片：一个从原始切片的开头到 <code>mid</code> 索引，另一个从 <code>mid</code> 到切片的末尾。</p>
<p>当我们尝试编译 Listing 20-5 中的代码时，我们会得到一个错误。</p>
<pre><code class="language-console">$ cargo run
   Compiling unsafe-example v0.1.0 (file:///projects/unsafe-example)
error[E0499]: cannot borrow `*values` as mutable more than once at a time
 --&gt; src/main.rs:6:31
  |
1 | fn split_at_mut(values: &amp;mut [i32], mid: usize) -&gt; (&amp;mut [i32], &amp;mut [i32]) {
  |                         - let's call the lifetime of this reference `'1`
...
6 |     (&amp;mut values[..mid], &amp;mut values[mid..])
  |     --------------------------^^^^^^--------
  |     |     |                   |
  |     |     |                   second mutable borrow occurs here
  |     |     first mutable borrow occurs here
  |     returning this value requires that `*values` is borrowed for `'1`
  |
  = help: use `.split_at_mut(position)` to obtain two mutable non-overlapping sub-slices

For more information about this error, try `rustc --explain E0499`.
error: could not compile `unsafe-example` (bin "unsafe-example") due to 1 previous error
</code></pre>
<p>Rust 的借用检查器无法理解我们正在借用切片的不同部分；它只知道我们正在从同一个切片中借用两次。借用切片的不同部分在本质上是没问题的，因为这两个切片不重叠，但 Rust 不够聪明，无法理解这一点。当我们知道代码没问题，但 Rust 不知道时，就该使用不安全的代码了。</p>
<p>Listing 20-6 展示了如何使用 <code>unsafe</code> 块、裸指针和一些对不安全函数的调用来使 <code>split_at_mut</code> 的实现工作。</p>
<figure class="listing">
<pre><pre class="playground"><code class="language-rust edition2024">use std::slice;

fn split_at_mut(values: &amp;mut [i32], mid: usize) -&gt; (&amp;mut [i32], &amp;mut [i32]) {
    let len = values.len();
    let ptr = values.as_mut_ptr();

    assert!(mid &lt;= len);

    unsafe {
        (
            slice::from_raw_parts_mut(ptr, mid),
            slice::from_raw_parts_mut(ptr.add(mid), len - mid),
        )
    }
}
<span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    let mut vector = vec![1, 2, 3, 4, 5, 6];
</span><span class="boring">    let (left, right) = split_at_mut(&amp;mut vector, 3);
</span><span class="boring">}</span></code></pre></pre>
<figcaption>Listing 20-6: 在 <code>split_at_mut</code> 函数的实现中使用不安全代码</figcaption>
</figure>
<p>回想一下第 4 章中的<a href="ch04-03-slices.html#the-slice-type">“切片类型”</a><!-- ignore -->，切片是指向某些数据的指针和切片的长度。我们使用 <code>len</code> 方法获取切片的长度，使用 <code>as_mut_ptr</code> 方法访问切片的裸指针。在这种情况下，因为我们有一个 <code>i32</code> 值的可变切片，<code>as_mut_ptr</code> 返回一个类型为 <code>*mut i32</code> 的裸指针，我们将其存储在变量 <code>ptr</code> 中。</p>
<p>我们保留了 <code>mid</code> 索引在切片内的断言。然后我们进入不安全的代码：<code>slice::from_raw_parts_mut</code> 函数接受一个裸指针和一个长度，并创建一个切片。我们使用它来创建一个从 <code>ptr</code> 开始且长度为 <code>mid</code> 的切片。然后我们在 <code>ptr</code> 上调用 <code>add</code> 方法，参数为 <code>mid</code>，以获取一个从 <code>mid</code> 开始的裸指针，并使用该指针和 <code>mid</code> 之后的剩余项数作为长度创建一个切片。</p>
<p><code>slice::from_raw_parts_mut</code> 函数是不安全的，因为它接受一个裸指针，并且必须相信这个指针是有效的。裸指针上的 <code>add</code> 方法也是不安全的，因为它必须相信偏移位置也是一个有效的指针。因此，我们必须在调用 <code>slice::from_raw_parts_mut</code> 和 <code>add</code> 时使用 <code>unsafe</code> 块。通过查看代码并添加 <code>mid</code> 必须小于或等于 <code>len</code> 的断言，我们可以确定 <code>unsafe</code> 块中使用的所有裸指针都是指向切片内数据的有效指针。这是一个可接受且适当的使用 <code>unsafe</code> 的方式。</p>
<p>注意，我们不需要将生成的 <code>split_at_mut</code> 函数标记为 <code>unsafe</code>，我们可以从安全的 Rust 中调用这个函数。我们已经创建了一个安全抽象，通过使用不安全代码的函数实现，以安全的方式使用不安全代码，因为它只从该函数可以访问的数据中创建有效的指针。</p>
<p>相比之下，Listing 20-7 中使用 <code>slice::from_raw_parts_mut</code> 的代码在使用切片时可能会崩溃。这段代码接受一个任意的内存位置并创建一个长度为 10,000 的切片。</p>
<figure class="listing">
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">fn main() {
</span>    use std::slice;

    let address = 0x01234usize;
    let r = address as *mut i32;

    let values: &amp;[i32] = unsafe { slice::from_raw_parts_mut(r, 10000) };
<span class="boring">}</span></code></pre></pre>
<figcaption>Listing 20-7: 从任意内存位置创建切片</figcaption>
</figure>
<p>我们不拥有这个任意位置的内存，也没有保证这段代码创建的切片包含有效的 <code>i32</code> 值。尝试将 <code>values</code> 当作一个有效的切片使用会导致未定义行为。</p>
<h4 id="使用-extern-函数调用外部代码"><a class="header" href="#使用-extern-函数调用外部代码">使用 <code>extern</code> 函数调用外部代码</a></h4>
<p>有时，你的 Rust 代码可能需要与用另一种语言编写的代码进行交互。为此，Rust 提供了 <code>extern</code> 关键字，用于创建和使用<strong>外部函数接口（FFI）</strong>。FFI 是一种编程语言定义函数并允许另一种（外部的）编程语言调用这些函数的方式。</p>
<p>Listing 20-8 演示了如何设置与 C 标准库中的 <code>abs</code> 函数的集成。在 <code>extern</code> 块中声明的函数通常从 Rust 代码中调用是不安全的，因此 <code>extern</code> 块也必须标记为 <code>unsafe</code>。原因是其他语言不强制执行 Rust 的规则和保证，Rust 也无法检查它们，因此程序员有责任确保安全。</p>
<figure class="listing">
<span class="file-name">Filename: src/main.rs</span>
<pre><pre class="playground"><code class="language-rust edition2024">unsafe extern "C" {
    fn abs(input: i32) -&gt; i32;
}

fn main() {
    unsafe {
        println!("Absolute value of -3 according to C: {}", abs(-3));
    }
}</code></pre></pre>
<figcaption>Listing 20-8: 声明并调用另一种语言中定义的 <code>extern</code> 函数</figcaption>
</figure>
<p>在 <code>unsafe extern "C"</code> 块中，我们列出了我们想要调用的另一种语言的外部函数的名称和签名。<code>"C"</code> 部分定义了外部函数使用的<strong>应用程序二进制接口（ABI）</strong>：ABI 定义了如何在汇编级别调用函数。<code>"C"</code> ABI 是最常见的，遵循 C 编程语言的 ABI。</p>
<p>在 <code>unsafe extern</code> 块中声明的每个项都是隐式 <code>unsafe</code> 的。然而，一些 FFI 函数<strong>是</strong>安全调用的。例如，C 标准库中的 <code>abs</code> 函数没有任何内存安全考虑，我们知道它可以与任何 <code>i32</code> 一起调用。在这种情况下，我们可以使用 <code>safe</code> 关键字来表示这个特定的函数是安全调用的，即使它在 <code>unsafe extern</code> 块中。一旦我们做出这个更改，调用它就不再需要 <code>unsafe</code> 块，如 Listing 20-9 所示。</p>
<figure class="listing">
<span class="file-name">Filename: src/main.rs</span>
<pre><pre class="playground"><code class="language-rust edition2024">unsafe extern "C" {
    safe fn abs(input: i32) -&gt; i32;
}

fn main() {
    println!("Absolute value of -3 according to C: {}", abs(-3));
}</code></pre></pre>
<figcaption>Listing 20-9: 在 <code>unsafe extern</code> 块中显式标记函数为 <code>safe</code> 并安全调用</figcaption>
</figure>
<p>将函数标记为 <code>safe</code> 并不会使其变得安全！相反，这是你向 Rust 做出的承诺，即它是安全的。你仍然有责任确保这个承诺得到遵守！</p>
<section class="note" aria-role="note">
<h4 id="从其他语言调用-rust-函数"><a class="header" href="#从其他语言调用-rust-函数">从其他语言调用 Rust 函数</a></h4>
<p>我们也可以使用 <code>extern</code> 创建一个接口，允许其他语言调用 Rust 函数。我们不需要创建整个 <code>extern</code> 块，而是在相关函数的 <code>fn</code> 关键字前添加 <code>extern</code> 关键字并指定要使用的 ABI。我们还需要添加一个 <code>#[unsafe(no_mangle)]</code> 注解，告诉 Rust 编译器不要对这个函数的名称进行混淆。<strong>混淆</strong>是编译器将我们给函数的名称更改为包含更多信息的名称，以供编译过程的其他部分使用，但人类可读性较差。每种编程语言编译器对名称的混淆方式略有不同，因此为了让 Rust 函数能够被其他语言调用，我们必须禁用 Rust 编译器的名称混淆。这是不安全的，因为如果没有内置的混淆，库之间可能会发生名称冲突，因此我们有责任确保我们选择的名称在不混淆的情况下是安全导出的。</p>
<p>在以下示例中，我们使 <code>call_from_c</code> 函数可以从 C 代码中访问，在将其编译为共享库并从 C 中链接后：</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[unsafe(no_mangle)]
pub extern "C" fn call_from_c() {
    println!("Just called a Rust function from C!");
}
<span class="boring">}</span></code></pre></pre>
<p>这种 <code>extern</code> 的使用仅在属性中需要 <code>unsafe</code>，而不是在 <code>extern</code> 块中。</p>
</section>
<h3 id="访问或修改可变的静态变量"><a class="header" href="#访问或修改可变的静态变量">访问或修改可变的静态变量</a></h3>
<p>在本书中，我们还没有讨论过全局变量，Rust 确实支持全局变量，但它们可能会与 Rust 的所有权规则产生问题。如果两个线程访问同一个可变的全局变量，可能会导致数据竞争。</p>
<p>在 Rust 中，全局变量称为<strong>静态</strong>变量。Listing 20-10 展示了一个以字符串切片为值的静态变量的声明和使用示例。</p>
<figure class="listing">
<span class="file-name">Filename: src/main.rs</span>
<pre><pre class="playground"><code class="language-rust edition2024">static HELLO_WORLD: &amp;str = "Hello, world!";

fn main() {
    println!("name is: {HELLO_WORLD}");
}</code></pre></pre>
<figcaption>Listing 20-10: 定义和使用不可变的静态变量</figcaption>
</figure>
<p>静态变量类似于我们在第 3 章的<a href="ch03-01-variables-and-mutability.html#constants">“常量”</a><!-- ignore -->中讨论的常量。静态变量的名称通常使用 <code>SCREAMING_SNAKE_CASE</code> 命名约定。静态变量只能存储具有 <code>'static</code> 生命周期的引用，这意味着 Rust 编译器可以推断出生命周期，我们不需要显式注解它。访问不可变的静态变量是安全的。</p>
<p>不可变静态变量和常量之间的一个微妙区别是，静态变量的值在内存中有一个固定的地址。使用该值将始终访问相同的数据。另一方面，常量允许在每次使用时复制其数据。另一个区别是静态变量可以是可变的。访问和修改可变的静态变量是<strong>不安全的</strong>。Listing 20-11 展示了如何声明、访问和修改一个名为 <code>COUNTER</code> 的可变静态变量。</p>
<figure class="listing">
<span class="file-name">Filename: src/main.rs</span>
<pre><pre class="playground"><code class="language-rust edition2024">static mut COUNTER: u32 = 0;

/// SAFETY: Calling this from more than a single thread at a time is undefined
/// behavior, so you *must* guarantee you only call it from a single thread at
/// a time.
unsafe fn add_to_count(inc: u32) {
    unsafe {
        COUNTER += inc;
    }
}

fn main() {
    unsafe {
        // SAFETY: This is only called from a single thread in `main`.
        add_to_count(3);
        println!("COUNTER: {}", *(&amp;raw const COUNTER));
    }
}</code></pre></pre>
<figcaption>Listing 20-11: 读取或写入可变的静态变量是不安全的</figcaption>
</figure>
<p>与常规变量一样，我们使用 <code>mut</code> 关键字指定可变性。任何读取或写入 <code>COUNTER</code> 的代码都必须在 <code>unsafe</code> 块中。这段代码可以编译并打印 <code>COUNTER: 3</code>，正如我们所期望的那样，因为它是单线程的。如果有多个线程访问 <code>COUNTER</code>，可能会导致数据竞争，因此这是未定义行为。因此，我们需要将整个函数标记为 <code>unsafe</code>，并记录安全限制，以便任何调用该函数的人都知道他们可以安全地做什么和不做什么。</p>
<p>每当我们编写一个不安全的函数时，习惯上写一个以 <code>SAFETY</code> 开头的注释，解释调用者需要做什么才能安全地调用该函数。同样，每当我们执行不安全的操作时，习惯上写一个以 <code>SAFETY</code> 开头的注释，解释如何遵守安全规则。</p>
<p>此外，编译器不允许你创建对可变静态变量的引用。你只能通过使用裸借用操作符创建的裸指针来访问它。这包括在引用被隐式创建的情况下，例如在此代码列表中的 <code>println!</code> 中使用时。要求对静态可变变量的引用只能通过裸指针创建，这有助于使使用它们的安全要求更加明显。</p>
<p>对于全局可访问的可变数据，很难确保没有数据竞争，这就是为什么 Rust 认为可变的静态变量是不安全的。在可能的情况下，最好使用我们在第 16 章中讨论的并发技术和线程安全的智能指针，以便编译器检查来自不同线程的数据访问是否安全。</p>
<h3 id="实现不安全的-trait"><a class="header" href="#实现不安全的-trait">实现不安全的 Trait</a></h3>
<p>我们可以使用 <code>unsafe</code> 来实现一个不安全的 trait。当 trait 的至少一个方法有一些编译器无法验证的不变量时，该 trait 是不安全的。我们通过在 <code>trait</code> 前添加 <code>unsafe</code> 关键字并将 trait 的实现也标记为 <code>unsafe</code> 来声明一个 trait 是不安全的，如 Listing 20-12 所示。</p>
<figure class="listing">
<pre><pre class="playground"><code class="language-rust edition2024">unsafe trait Foo {
    // methods go here
}

unsafe impl Foo for i32 {
    // method implementations go here
}
<span class="boring">
</span><span class="boring">fn main() {}</span></code></pre></pre>
<figcaption>Listing 20-12: 定义和实现一个不安全的 trait</figcaption>
</figure>
<p>通过使用 <code>unsafe impl</code>，我们承诺我们将遵守编译器无法验证的不变量。</p>
<p>作为一个例子，回想一下我们在第 16 章的<a href="ch16-04-extensible-concurrency-sync-and-send.html#extensible-concurrency-with-the-sync-and-send-traits">“使用 <code>Sync</code> 和 <code>Send</code> trait 扩展并发”</a><!-- ignore -->中讨论的 <code>Sync</code> 和 <code>Send</code> 标记 trait：如果我们的类型完全由其他实现了 <code>Send</code> 和 <code>Sync</code> 的类型组成，编译器会自动实现这些 trait。如果我们实现一个包含未实现 <code>Send</code> 或 <code>Sync</code> 的类型（例如裸指针）的类型，并且我们希望将该类型标记为 <code>Send</code> 或 <code>Sync</code>，我们必须使用 <code>unsafe</code>。Rust 无法验证我们的类型是否遵守可以安全地跨线程发送或从多个线程访问的保证；因此，我们需要手动进行这些检查，并使用 <code>unsafe</code> 表示。</p>
<h3 id="访问-union-的字段"><a class="header" href="#访问-union-的字段">访问 <code>union</code> 的字段</a></h3>
<p>只能在 <code>unsafe</code> 中执行的最后一个操作是访问 <code>union</code> 的字段。<code>union</code> 类似于 <code>struct</code>，但在特定实例中只使用一个声明的字段。<code>union</code> 主要用于与 C 代码中的 <code>union</code> 进行交互。访问 <code>union</code> 字段是不安全的，因为 Rust 无法保证当前存储在 <code>union</code> 实例中的数据类型。你可以在 <a href="../reference/items/unions.html">Rust 参考</a> 中了解更多关于 <code>union</code> 的信息。</p>
<h3 id="使用-miri-检查不安全代码"><a class="header" href="#使用-miri-检查不安全代码">使用 Miri 检查不安全代码</a></h3>
<p>在编写不安全代码时，你可能希望检查你编写的代码是否实际上是安全和正确的。最好的方法之一是使用 Miri，这是一个官方的 Rust 工具，用于检测未定义行为。虽然借用检查器是一个在编译时工作的<strong>静态</strong>工具，但 Miri 是一个在运行时工作的<strong>动态</strong>工具。它通过运行你的程序或其测试套件来检查你的代码，并在你违反它理解的 Rust 工作规则时检测到。</p>
<p>使用 Miri 需要 Rust 的 nightly 版本（我们在<a href="appendix-07-nightly-rust.html">附录 G：Rust 的构建和“Nightly Rust”</a>中讨论更多）。你可以通过输入 <code>rustup +nightly component add miri</code> 来安装 Rust 的 nightly 版本和 Miri 工具。这不会改变你的项目使用的 Rust 版本；它只是将该工具添加到你的系统中，以便你可以在需要时使用它。你可以通过输入 <code>cargo +nightly miri run</code> 或 <code>cargo +nightly miri test</code> 在项目上运行 Miri。</p>
<p>为了了解这有多有帮助，考虑当我们对 Listing 20-11 运行它时会发生什么。</p>
<pre><code class="language-console">$ cargo +nightly miri run
   Compiling unsafe-example v0.1.0 (file:///projects/unsafe-example)
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.01s
     Running `file:///home/.rustup/toolchains/nightly/bin/cargo-miri runner target/miri/debug/unsafe-example`
COUNTER: 3
</code></pre>
<p>Miri 正确地警告我们，我们有对可变数据的共享引用。在这里，Miri 只发出警告，因为在这种情况下这并不保证是未定义行为，它也没有告诉我们如何修复问题。但至少我们知道存在未定义行为的风险，并可以思考如何使代码安全。在某些情况下，Miri 还可以检测到明显的错误——<strong>肯定</strong>错误的代码模式——并提出如何修复这些错误的建议。</p>
<p>Miri 并不能捕捉到你在编写不安全代码时可能犯的所有错误。Miri 是一个动态分析工具，因此它只能捕捉实际运行的代码中的问题。这意味着你需要将其与良好的测试技术结合使用，以增加对你编写的不安全代码的信心。Miri 也不涵盖你的代码可能不健全的每一种方式。</p>
<p>换句话说：如果 Miri <strong>确实</strong>捕捉到了问题，你知道有一个 bug，但仅仅因为 Miri <strong>没有</strong>捕捉到 bug 并不意味着没有问题。它可以捕捉到很多问题。尝试在本章的其他不安全代码示例上运行它，看看它会说什么！</p>
<p>你可以在 <a href="https://github.com/rust-lang/miri">Miri 的 GitHub 仓库</a> 中了解更多关于 Miri 的信息。</p>
<h3 id="何时使用不安全代码"><a class="header" href="#何时使用不安全代码">何时使用不安全代码</a></h3>
<p>使用 <code>unsafe</code> 来使用刚刚讨论的五个超能力并不是错误的，甚至不会受到批评，但正确使用 <code>unsafe</code> 代码更棘手，因为编译器无法帮助维护内存安全。当你有理由使用 <code>unsafe</code> 代码时，你可以这样做，并且显式的 <code>unsafe</code> 注释使得在问题发生时更容易追踪问题的根源。每当你编写不安全代码时，你可以使用 Miri 来帮助你更有信心地认为你编写的代码遵守了 Rust 的规则。</p>
<p>要更深入地探索如何有效地使用不安全的 Rust，请阅读 Rust 的官方指南 <a href="https://doc.rust-lang.org/nomicon/">Rustonomicon</a>。</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="ch20-00-advanced-features.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="ch20-02-advanced-traits.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="ch20-00-advanced-features.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="ch20-02-advanced-traits.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->
        <script src="ferris.js"></script>


    </div>
    </body>
</html>
