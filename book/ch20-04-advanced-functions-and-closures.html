<!DOCTYPE HTML>
<html lang="en" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>高级函数和闭包 - Rust编程语言</title>


        <!-- Custom HTML head -->

        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" id="highlight-css" href="highlight.css">
        <link rel="stylesheet" id="tomorrow-night-css" href="tomorrow-night.css">
        <link rel="stylesheet" id="ayu-highlight-css" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="ferris.css">
        <link rel="stylesheet" href="theme/2018-edition.css">
        <link rel="stylesheet" href="theme/semantic-notes.css">
        <link rel="stylesheet" href="theme/listing.css">


        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="toc.js"></script>
    </head>
    <body>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var sidebar = null;
            var sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Rust编程语言</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/lxqddd/rust-book-cn" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h2 id="高级函数与闭包"><a class="header" href="#高级函数与闭包">高级函数与闭包</a></h2>
<p>本节探讨了一些与函数和闭包相关的高级特性，包括函数指针和返回闭包。</p>
<h3 id="函数指针"><a class="header" href="#函数指针">函数指针</a></h3>
<p>我们已经讨论过如何将闭包传递给函数；你也可以将常规函数传递给函数！当你想要传递一个已经定义的函数而不是定义一个新的闭包时，这种技术非常有用。函数会被强制转换为 <code>fn</code> 类型（小写的 <em>f</em>），不要与 <code>Fn</code> 闭包特征混淆。<code>fn</code> 类型被称为<strong>函数指针</strong>。通过函数指针传递函数允许你将函数作为参数传递给其他函数。</p>
<p>指定参数为函数指针的语法与闭包的语法类似，如 Listing 20-28 所示，我们定义了一个函数 <code>add_one</code>，它将参数加 1。函数 <code>do_twice</code> 接受两个参数：一个是指向任何接受 <code>i32</code> 参数并返回 <code>i32</code> 的函数的函数指针，另一个是 <code>i32</code> 值。<code>do_twice</code> 函数调用函数 <code>f</code> 两次，传递 <code>arg</code> 值，然后将两次函数调用的结果相加。<code>main</code> 函数使用 <code>add_one</code> 和 <code>5</code> 作为参数调用 <code>do_twice</code>。</p>
<figure class="listing">
<span class="file-name">Filename: src/main.rs</span>
<pre><pre class="playground"><code class="language-rust edition2024">fn add_one(x: i32) -&gt; i32 {
    x + 1
}

fn do_twice(f: fn(i32) -&gt; i32, arg: i32) -&gt; i32 {
    f(arg) + f(arg)
}

fn main() {
    let answer = do_twice(add_one, 5);

    println!("The answer is: {answer}");
}</code></pre></pre>
<figcaption>Listing 20-28: 使用 <code>fn</code> 类型接受函数指针作为参数</figcaption>
</figure>
<p>这段代码会打印出 <code>The answer is: 12</code>。我们指定 <code>do_twice</code> 中的参数 <code>f</code> 是一个接受一个 <code>i32</code> 类型参数并返回 <code>i32</code> 的 <code>fn</code>。然后我们可以在 <code>do_twice</code> 的函数体中调用 <code>f</code>。在 <code>main</code> 中，我们可以将函数名 <code>add_one</code> 作为第一个参数传递给 <code>do_twice</code>。</p>
<p>与闭包不同，<code>fn</code> 是一个类型而不是一个特征，因此我们直接指定 <code>fn</code> 作为参数类型，而不是声明一个泛型类型参数并使用 <code>Fn</code> 特征作为特征约束。</p>
<p>函数指针实现了所有三个闭包特征（<code>Fn</code>、<code>FnMut</code> 和 <code>FnOnce</code>），这意味着你总是可以将函数指针作为参数传递给期望闭包的函数。最好使用泛型类型和闭包特征之一来编写函数，这样你的函数可以接受函数或闭包。</p>
<p>话虽如此，当你只想接受 <code>fn</code> 而不接受闭包时，一个例子是与没有闭包的外部代码交互：C 函数可以接受函数作为参数，但 C 没有闭包。</p>
<p>作为一个可以使用内联定义的闭包或命名函数的例子，让我们看看标准库中 <code>Iterator</code> 特征提供的 <code>map</code> 方法的使用。为了使用 <code>map</code> 方法将数字向量转换为字符串向量，我们可以使用闭包，如 Listing 20-29 所示。</p>
<figure class="listing">
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">fn main() {
</span>    let list_of_numbers = vec![1, 2, 3];
    let list_of_strings: Vec&lt;String&gt; =
        list_of_numbers.iter().map(|i| i.to_string()).collect();
<span class="boring">}</span></code></pre></pre>
<figcaption>Listing 20-29: 使用闭包与 <code>map</code> 方法将数字转换为字符串</figcaption>
</figure>
<p>或者我们可以将函数名作为 <code>map</code> 的参数，而不是闭包。Listing 20-30 展示了这种情况。</p>
<figure class="listing">
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">fn main() {
</span>    let list_of_numbers = vec![1, 2, 3];
    let list_of_strings: Vec&lt;String&gt; =
        list_of_numbers.iter().map(ToString::to_string).collect();
<span class="boring">}</span></code></pre></pre>
<figcaption>Listing 20-30: 使用 <code>String::to_string</code> 方法将数字转换为字符串</figcaption>
</figure>
<p>注意，我们必须使用我们在 <a href="ch20-02-advanced-traits.html#advanced-traits">“高级特征”</a> 中讨论的完全限定语法，因为有多个名为 <code>to_string</code> 的函数可用。</p>
<p>在这里，我们使用了 <code>ToString</code> 特征中定义的 <code>to_string</code> 函数，标准库为任何实现了 <code>Display</code> 的类型实现了这个特征。</p>
<p>回想一下第 6 章中的 <a href="ch06-01-defining-an-enum.html#enum-values">“枚举值”</a>，我们定义的每个枚举变体的名称也会成为一个初始化函数。我们可以将这些初始化函数作为实现闭包特征的函数指针，这意味着我们可以将初始化函数指定为接受闭包的方法的参数，如 Listing 20-31 所示。</p>
<figure class="listing">
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">fn main() {
</span>    enum Status {
        Value(u32),
        Stop,
    }

    let list_of_statuses: Vec&lt;Status&gt; = (0u32..20).map(Status::Value).collect();
<span class="boring">}</span></code></pre></pre>
<figcaption>Listing 20-31: 使用枚举初始化函数与 <code>map</code> 方法从数字创建 <code>Status</code> 实例</figcaption>
</figure>
<p>在这里，我们通过使用 <code>Status::Value</code> 的初始化函数，在 <code>map</code> 调用的范围内为每个 <code>u32</code> 值创建 <code>Status::Value</code> 实例。有些人喜欢这种风格，有些人喜欢使用闭包。它们编译为相同的代码，所以使用你觉得更清晰的风格。</p>
<h3 id="返回闭包"><a class="header" href="#返回闭包">返回闭包</a></h3>
<p>闭包由特征表示，这意味着你不能直接返回闭包。在大多数情况下，你可能想要返回一个特征，你可以使用实现该特征的具体类型作为函数的返回值。然而，对于闭包，你通常不能这样做，因为它们没有可返回的具体类型。例如，如果闭包从其作用域中捕获了任何值，你就不允许使用函数指针 <code>fn</code> 作为返回类型。</p>
<p>相反，你通常会使用我们在第 10 章中学到的 <code>impl Trait</code> 语法。你可以返回任何函数类型，使用 <code>Fn</code>、<code>FnOnce</code> 和 <code>FnMut</code>。例如，Listing 20-32 中的代码将正常工作。</p>
<figure class="listing">
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn returns_closure() -&gt; impl Fn(i32) -&gt; i32 {
    |x| x + 1
}
<span class="boring">}</span></code></pre></pre>
<figcaption>Listing 20-32: 使用 <code>impl Trait</code> 语法从函数返回闭包</figcaption>
</figure>
<p>然而，正如我们在第 13 章的 <a href="ch13-01-closures.html#closure-type-inference-and-annotation">“闭包类型推断和注解”</a> 中指出的那样，每个闭包也是其自己独特的类型。如果你需要处理具有相同签名但不同实现的多个函数，你将需要为它们使用特征对象。考虑如果你编写如 Listing 20-33 所示的代码会发生什么。</p>
<figure class="listing">
<span class="file-name">Filename: src/main.rs</span>
<pre><code class="language-rust ignore does_not_compile">fn main() {
    let handlers = vec![returns_closure(), returns_initialized_closure(123)];
    for handler in handlers {
        let output = handler(5);
        println!("{output}");
    }
}

fn returns_closure() -&gt; impl Fn(i32) -&gt; i32 {
    |x| x + 1
}

fn returns_initialized_closure(init: i32) -&gt; impl Fn(i32) -&gt; i32 {
    move |x| x + init
}</code></pre>
<figcaption>Listing 20-33: 创建一个由返回 <code>impl Fn</code> 的函数定义的闭包的 <code>Vec&lt;T&gt;</code></figcaption>
</figure>
<p>这里我们有两个函数，<code>returns_closure</code> 和 <code>returns_initialized_closure</code>，它们都返回 <code>impl Fn(i32) -&gt; i32</code>。注意，它们返回的闭包是不同的，尽管它们实现了相同的类型。如果我们尝试编译这个代码，Rust 会告诉我们它不会工作：</p>
<pre><code class="language-text">$ cargo build
   Compiling functions-example v0.1.0 (file:///projects/functions-example)
    error[E0308]: mismatched types
    --&gt; src/main.rs:4:9
    |
    4  |         returns_initialized_closure(123)
    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected opaque type, found a different opaque type
    ...
    12 | fn returns_closure() -&gt; impl Fn(i32) -&gt; i32 {
    |                         ------------------- the expected opaque type
    ...
    16 | fn returns_initialized_closure(init: i32) -&gt; impl Fn(i32) -&gt; i32 {
    |                                              ------------------- the found opaque type
    |
    = note: expected opaque type `impl Fn(i32) -&gt; i32` (opaque type at &lt;src/main.rs:12:25&gt;)
                found opaque type `impl Fn(i32) -&gt; i32` (opaque type at &lt;src/main.rs:16:46&gt;)
    = note: distinct uses of `impl Trait` result in different opaque types

    For more information about this error, try `rustc --explain E0308`.
    error: could not compile `functions-example` (bin "functions-example") due to 1 previous error
</code></pre>
<p>错误信息告诉我们，每当我们返回一个 <code>impl Trait</code> 时，Rust 会创建一个独特的<strong>不透明类型</strong>，这是一种我们无法看到 Rust 为我们构建的细节的类型。因此，即使这些函数都返回实现了相同特征 <code>Fn(i32) -&gt; i32</code> 的闭包，Rust 为每个生成的类型是不同的。（这与 Rust 为不同的异步块生成不同的具体类型类似，即使它们具有相同的输出类型，正如我们在第 17 章的 <a href="ch17-03-more-futures.html">“处理任意数量的 Futures”</a> 中看到的那样。我们已经多次看到这个问题的解决方案：我们可以使用特征对象，如 Listing 20-34 所示。</p>
<figure class="listing">
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">fn main() {
</span><span class="boring">    let handlers = vec![returns_closure(), returns_initialized_closure(123)];
</span><span class="boring">    for handler in handlers {
</span><span class="boring">        let output = handler(5);
</span><span class="boring">        println!("{output}");
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>fn returns_closure() -&gt; Box&lt;dyn Fn(i32) -&gt; i32&gt; {
    Box::new(|x| x + 1)
}

fn returns_initialized_closure(init: i32) -&gt; Box&lt;dyn Fn(i32) -&gt; i32&gt; {
    Box::new(move |x| x + init)
}</code></pre></pre>
<figcaption>Listing 20-34: 创建一个由返回 <code>Box&lt;dyn Fn&gt;</code> 的函数定义的闭包的 <code>Vec&lt;T&gt;</code>，以便它们具有相同的类型</figcaption>
</figure>
<p>这段代码将正常编译。有关特征对象的更多信息，请参阅第 18 章的 <a href="ch18-02-trait-objects.html#using-trait-objects-that-allow-for-values-of-different-types">“使用允许不同类型值的特征对象”</a> 部分。</p>
<p>接下来，让我们看看宏！</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="ch20-03-advanced-types.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="ch20-05-macros.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="ch20-03-advanced-types.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="ch20-05-macros.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->
        <script src="ferris.js"></script>


    </div>
    </body>
</html>
