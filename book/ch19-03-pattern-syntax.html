<!DOCTYPE HTML>
<html lang="en" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>模式语法 - Rust编程语言</title>


        <!-- Custom HTML head -->

        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" id="highlight-css" href="highlight.css">
        <link rel="stylesheet" id="tomorrow-night-css" href="tomorrow-night.css">
        <link rel="stylesheet" id="ayu-highlight-css" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="ferris.css">
        <link rel="stylesheet" href="theme/2018-edition.css">
        <link rel="stylesheet" href="theme/semantic-notes.css">
        <link rel="stylesheet" href="theme/listing.css">


        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="toc.js"></script>
    </head>
    <body>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var sidebar = null;
            var sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Rust编程语言</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/lxqddd/rust-book-cn" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h2 id="模式语法"><a class="header" href="#模式语法">模式语法</a></h2>
<p>在本节中，我们将收集所有在模式中有效的语法，并讨论为什么以及何时可能想要使用每种语法。</p>
<h3 id="匹配字面量"><a class="header" href="#匹配字面量">匹配字面量</a></h3>
<p>正如你在第6章中看到的，你可以直接将模式与字面量匹配。以下代码给出了一些示例：</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">fn main() {
</span>    let x = 1;

    match x {
        1 =&gt; println!("one"),
        2 =&gt; println!("two"),
        3 =&gt; println!("three"),
        _ =&gt; println!("anything"),
    }
<span class="boring">}</span></code></pre></pre>
<p>这段代码会打印 <code>one</code>，因为 <code>x</code> 的值是 1。当你希望代码在获得特定具体值时采取行动时，这种语法非常有用。</p>
<h3 id="匹配命名变量"><a class="header" href="#匹配命名变量">匹配命名变量</a></h3>
<p>命名变量是不可反驳的模式，它们可以匹配任何值，我们在本书中已经多次使用它们。然而，当你在 <code>match</code>、<code>if let</code> 或 <code>while let</code> 表达式中使用命名变量时，会出现一个复杂情况。因为这些表达式都会开启一个新的作用域，所以作为模式一部分声明的变量会遮蔽外部同名的变量，就像所有变量一样。在 Listing 19-11 中，我们声明了一个名为 <code>x</code> 的变量，其值为 <code>Some(5)</code>，以及一个名为 <code>y</code> 的变量，其值为 <code>10</code>。然后我们在 <code>x</code> 的值上创建了一个 <code>match</code> 表达式。查看匹配分支中的模式以及最后的 <code>println!</code>，尝试在运行此代码或继续阅读之前弄清楚代码将打印什么。</p>
<figure class="listing">
<span class="file-name">Filename: src/main.rs</span>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">fn main() {
</span>    let x = Some(5);
    let y = 10;

    match x {
        Some(50) =&gt; println!("Got 50"),
        Some(y) =&gt; println!("Matched, y = {y}"),
        _ =&gt; println!("Default case, x = {x:?}"),
    }

    println!("at the end: x = {x:?}, y = {y}");
<span class="boring">}</span></code></pre></pre>
<figcaption>Listing 19-11: 一个 <code>match</code> 表达式，其中一个分支引入了一个新变量，遮蔽了现有的变量 <code>y</code></figcaption>
</figure>
<p>让我们逐步分析 <code>match</code> 表达式运行时的过程。第一个匹配分支中的模式与 <code>x</code> 的定义值不匹配，因此代码继续执行。</p>
<p>第二个匹配分支中的模式引入了一个名为 <code>y</code> 的新变量，它将匹配 <code>Some</code> 值中的任何值。因为我们在 <code>match</code> 表达式内部的新作用域中，所以这是一个新的 <code>y</code> 变量，而不是我们在开始时声明的值为 <code>10</code> 的 <code>y</code>。这个新的 <code>y</code> 绑定将匹配 <code>Some</code> 中的任何值，这正是我们在 <code>x</code> 中拥有的。因此，这个新的 <code>y</code> 绑定到 <code>x</code> 中 <code>Some</code> 的内部值。该值是 <code>5</code>，所以该分支的表达式执行并打印 <code>Matched, y = 5</code>。</p>
<p>如果 <code>x</code> 是 <code>None</code> 而不是 <code>Some(5)</code>，前两个分支中的模式都不会匹配，因此值会匹配到下划线。我们没有在下划线分支的模式中引入 <code>x</code> 变量，所以表达式中的 <code>x</code> 仍然是未被遮蔽的外部 <code>x</code>。在这种假设情况下，<code>match</code> 会打印 <code>Default case, x = None</code>。</p>
<p>当 <code>match</code> 表达式结束时，其作用域结束，内部的 <code>y</code> 的作用域也随之结束。最后的 <code>println!</code> 产生 <code>at the end: x = Some(5), y = 10</code>。</p>
<p>要创建一个比较外部 <code>x</code> 和 <code>y</code> 值的 <code>match</code> 表达式，而不是引入一个遮蔽现有 <code>y</code> 变量的新变量，我们需要使用匹配守卫条件。我们将在稍后的 <a href="#extra-conditionals-with-match-guards">“使用匹配守卫的额外条件”</a><!-- ignore --> 中讨论匹配守卫。</p>
<h3 id="多个模式"><a class="header" href="#多个模式">多个模式</a></h3>
<p>你可以使用 <code>|</code> 语法匹配多个模式，这是模式的 <em>或</em> 运算符。例如，在以下代码中，我们将 <code>x</code> 的值与匹配分支进行匹配，第一个分支有一个 <em>或</em> 选项，意味着如果 <code>x</code> 的值匹配该分支中的任何一个值，该分支的代码将运行：</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">fn main() {
</span>    let x = 1;

    match x {
        1 | 2 =&gt; println!("one or two"),
        3 =&gt; println!("three"),
        _ =&gt; println!("anything"),
    }
<span class="boring">}</span></code></pre></pre>
<p>这段代码会打印 <code>one or two</code>。</p>
<h3 id="使用--匹配值范围"><a class="header" href="#使用--匹配值范围">使用 <code>..=</code> 匹配值范围</a></h3>
<p><code>..=</code> 语法允许我们匹配一个包含范围的值。在以下代码中，当模式匹配给定范围内的任何值时，该分支将执行：</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">fn main() {
</span>    let x = 5;

    match x {
        1..=5 =&gt; println!("one through five"),
        _ =&gt; println!("something else"),
    }
<span class="boring">}</span></code></pre></pre>
<p>如果 <code>x</code> 是 <code>1</code>、<code>2</code>、<code>3</code>、<code>4</code> 或 <code>5</code>，第一个分支将匹配。这种语法比使用 <code>|</code> 运算符表达相同的意思更方便；如果我们使用 <code>|</code>，我们必须指定 <code>1 | 2 | 3 | 4 | 5</code>。指定一个范围要短得多，特别是如果我们想匹配，比如说，1 到 1,000 之间的任何数字！</p>
<p>编译器在编译时检查范围是否为空，因为 Rust 只能判断 <code>char</code> 和数值类型的范围是否为空，所以范围只允许用于数值或 <code>char</code> 值。</p>
<p>以下是一个使用 <code>char</code> 值范围的示例：</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">fn main() {
</span>    let x = 'c';

    match x {
        'a'..='j' =&gt; println!("early ASCII letter"),
        'k'..='z' =&gt; println!("late ASCII letter"),
        _ =&gt; println!("something else"),
    }
<span class="boring">}</span></code></pre></pre>
<p>Rust 可以判断 <code>'c'</code> 在第一个模式的范围内，并打印 <code>early ASCII letter</code>。</p>
<h3 id="解构以分解值"><a class="header" href="#解构以分解值">解构以分解值</a></h3>
<p>我们还可以使用模式来解构结构体、枚举和元组，以使用这些值的不同部分。让我们逐步分析每个值。</p>
<h4 id="解构结构体"><a class="header" href="#解构结构体">解构结构体</a></h4>
<p>Listing 19-12 展示了一个 <code>Point</code> 结构体，它有两个字段 <code>x</code> 和 <code>y</code>，我们可以使用 <code>let</code> 语句中的模式将其分解。</p>
<figure class="listing">
<span class="file-name">Filename: src/main.rs</span>
<pre><pre class="playground"><code class="language-rust edition2024">struct Point {
    x: i32,
    y: i32,
}

fn main() {
    let p = Point { x: 0, y: 7 };

    let Point { x: a, y: b } = p;
    assert_eq!(0, a);
    assert_eq!(7, b);
}</code></pre></pre>
<figcaption>Listing 19-12: 将结构体的字段解构为单独的变量</figcaption>
</figure>
<p>这段代码创建了变量 <code>a</code> 和 <code>b</code>，它们分别匹配 <code>p</code> 结构体的 <code>x</code> 和 <code>y</code> 字段的值。这个示例表明，模式中的变量名不必与结构体的字段名匹配。然而，通常会将变量名与字段名匹配，以便更容易记住哪些变量来自哪些字段。由于这种常见用法，并且因为写 <code>let Point { x: x, y: y } = p;</code> 包含大量重复，Rust 为匹配结构体字段的模式提供了一种简写形式：你只需要列出结构体字段的名称，模式创建的变量将具有相同的名称。Listing 19-13 的行为与 Listing 19-12 中的代码相同，但在 <code>let</code> 模式中创建的变量是 <code>x</code> 和 <code>y</code>，而不是 <code>a</code> 和 <code>b</code>。</p>
<figure class="listing">
<span class="file-name">Filename: src/main.rs</span>
<pre><pre class="playground"><code class="language-rust edition2024">struct Point {
    x: i32,
    y: i32,
}

fn main() {
    let p = Point { x: 0, y: 7 };

    let Point { x, y } = p;
    assert_eq!(0, x);
    assert_eq!(7, y);
}</code></pre></pre>
<figcaption>Listing 19-13: 使用结构体字段简写形式解构结构体字段</figcaption>
</figure>
<p>这段代码创建了变量 <code>x</code> 和 <code>y</code>，它们分别匹配 <code>p</code> 变量的 <code>x</code> 和 <code>y</code> 字段。结果是变量 <code>x</code> 和 <code>y</code> 包含来自 <code>p</code> 结构体的值。</p>
<p>我们还可以在结构体模式中使用字面值作为部分模式，而不是为所有字段创建变量。这样做允许我们在创建变量以解构其他字段的同时，测试某些字段的特定值。</p>
<p>在 Listing 19-14 中，我们有一个 <code>match</code> 表达式，它将 <code>Point</code> 值分为三种情况：直接位于 <code>x</code> 轴上的点（当 <code>y = 0</code> 时为真）、位于 <code>y</code> 轴上的点（<code>x = 0</code>）或不在任何轴上的点。</p>
<figure class="listing">
<span class="file-name">Filename: src/main.rs</span>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">struct Point {
</span><span class="boring">    x: i32,
</span><span class="boring">    y: i32,
</span><span class="boring">}
</span><span class="boring">
</span>fn main() {
    let p = Point { x: 0, y: 7 };

    match p {
        Point { x, y: 0 } =&gt; println!("On the x axis at {x}"),
        Point { x: 0, y } =&gt; println!("On the y axis at {y}"),
        Point { x, y } =&gt; {
            println!("On neither axis: ({x}, {y})");
        }
    }
}</code></pre></pre>
<figcaption>Listing 19-14: 在一个模式中解构并匹配字面值</figcaption>
</figure>
<p>第一个分支将通过指定 <code>y</code> 字段的值与字面量 <code>0</code> 匹配来匹配任何位于 <code>x</code> 轴上的点。该模式仍然创建一个 <code>x</code> 变量，我们可以在该分支的代码中使用它。</p>
<p>类似地，第二个分支通过指定 <code>x</code> 字段的值与 <code>0</code> 匹配来匹配任何位于 <code>y</code> 轴上的点，并为 <code>y</code> 字段的值创建一个变量 <code>y</code>。第三个分支没有指定任何字面量，因此它匹配任何其他 <code>Point</code>，并为 <code>x</code> 和 <code>y</code> 字段创建变量。</p>
<p>在这个例子中，值 <code>p</code> 通过 <code>x</code> 包含 <code>0</code> 匹配第二个分支，因此这段代码将打印 <code>On the y axis at 7</code>。</p>
<p>记住，<code>match</code> 表达式在找到第一个匹配的模式后就会停止检查分支，所以即使 <code>Point { x: 0, y: 0}</code> 位于 <code>x</code> 轴和 <code>y</code> 轴上，这段代码也只会打印 <code>On the x axis at 0</code>。</p>
<h4 id="解构枚举"><a class="header" href="#解构枚举">解构枚举</a></h4>
<p>我们在本书中已经解构过枚举（例如 Listing 6-5），但我们还没有明确讨论过解构枚举的模式与枚举内存储的数据定义方式相对应。作为一个例子，在 Listing 19-15 中，我们使用了 Listing 6-2 中的 <code>Message</code> 枚举，并编写了一个 <code>match</code>，其中的模式将解构每个内部值。</p>
<figure class="listing">
<span class="file-name">Filename: src/main.rs</span>
<pre><pre class="playground"><code class="language-rust edition2024">enum Message {
    Quit,
    Move { x: i32, y: i32 },
    Write(String),
    ChangeColor(i32, i32, i32),
}

fn main() {
    let msg = Message::ChangeColor(0, 160, 255);

    match msg {
        Message::Quit =&gt; {
            println!("The Quit variant has no data to destructure.");
        }
        Message::Move { x, y } =&gt; {
            println!("Move in the x direction {x} and in the y direction {y}");
        }
        Message::Write(text) =&gt; {
            println!("Text message: {text}");
        }
        Message::ChangeColor(r, g, b) =&gt; {
            println!("Change color to red {r}, green {g}, and blue {b}");
        }
    }
}</code></pre></pre>
<figcaption>Listing 19-15: 解构包含不同类型值的枚举变体</figcaption>
</figure>
<p>这段代码将打印 <code>Change color to red 0, green 160, and blue 255</code>。尝试更改 <code>msg</code> 的值以查看其他分支的代码运行。</p>
<p>对于没有任何数据的枚举变体，如 <code>Message::Quit</code>，我们无法进一步解构该值。我们只能匹配字面量 <code>Message::Quit</code> 值，并且该模式中没有变量。</p>
<p>对于类似结构体的枚举变体，如 <code>Message::Move</code>，我们可以使用类似于我们指定匹配结构体的模式。在变体名称之后，我们放置花括号，然后列出带有变量的字段，以便我们在该分支的代码中使用这些部分。这里我们使用了 Listing 19-13 中的简写形式。</p>
<p>对于类似元组的枚举变体，如 <code>Message::Write</code>，它包含一个元素的元组，以及 <code>Message::ChangeColor</code>，它包含三个元素的元组，模式类似于我们指定匹配元组的模式。模式中的变量数量必须与我们匹配的变体中的元素数量相匹配。</p>
<h4 id="解构嵌套结构体和枚举"><a class="header" href="#解构嵌套结构体和枚举">解构嵌套结构体和枚举</a></h4>
<p>到目前为止，我们的示例都是匹配一层深度的结构体或枚举，但匹配也可以处理嵌套项！例如，我们可以重构 Listing 19-15 中的代码，以支持 <code>ChangeColor</code> 消息中的 RGB 和 HSV 颜色，如 Listing 19-16 所示。</p>
<figure class="listing">
<pre><pre class="playground"><code class="language-rust edition2024">enum Color {
    Rgb(i32, i32, i32),
    Hsv(i32, i32, i32),
}

enum Message {
    Quit,
    Move { x: i32, y: i32 },
    Write(String),
    ChangeColor(Color),
}

fn main() {
    let msg = Message::ChangeColor(Color::Hsv(0, 160, 255));

    match msg {
        Message::ChangeColor(Color::Rgb(r, g, b)) =&gt; {
            println!("Change color to red {r}, green {g}, and blue {b}");
        }
        Message::ChangeColor(Color::Hsv(h, s, v)) =&gt; {
            println!("Change color to hue {h}, saturation {s}, value {v}");
        }
        _ =&gt; (),
    }
}</code></pre></pre>
<figcaption>Listing 19-16: 匹配嵌套枚举</figcaption>
</figure>
<p><code>match</code> 表达式中的第一个分支的模式匹配一个包含 <code>Color::Rgb</code> 变体的 <code>Message::ChangeColor</code> 枚举变体；然后模式绑定到三个内部的 <code>i32</code> 值。第二个分支的模式也匹配一个 <code>Message::ChangeColor</code> 枚举变体，但内部枚举匹配 <code>Color::Hsv</code>。我们可以在一个 <code>match</code> 表达式中指定这些复杂的条件，即使涉及两个枚举。</p>
<h4 id="解构结构体和元组"><a class="header" href="#解构结构体和元组">解构结构体和元组</a></h4>
<p>我们可以以更复杂的方式混合、匹配和嵌套解构模式。以下示例展示了一个复杂的解构，我们在元组中嵌套结构体和元组，并解构出所有原始值：</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">fn main() {
</span><span class="boring">    struct Point {
</span><span class="boring">        x: i32,
</span><span class="boring">        y: i32,
</span><span class="boring">    }
</span><span class="boring">
</span>    let ((feet, inches), Point { x, y }) = ((3, 10), Point { x: 3, y: -10 });
<span class="boring">}</span></code></pre></pre>
<p>这段代码让我们将复杂类型分解为其组成部分，以便我们可以分别使用我们感兴趣的值。</p>
<p>使用模式进行解构是一种方便的方式，可以分别使用值的各个部分，例如结构体中的每个字段的值。</p>
<h3 id="忽略模式中的值"><a class="header" href="#忽略模式中的值">忽略模式中的值</a></h3>
<p>你已经看到，有时忽略模式中的值是有用的，例如在 <code>match</code> 的最后一个分支中，以获得一个不执行任何操作但涵盖所有剩余可能值的 catchall。有几种方法可以忽略模式中的整个值或部分值：使用 <code>_</code> 模式（你已经见过）、在另一个模式中使用 <code>_</code> 模式、使用以下划线开头的名称，或使用 <code>..</code> 忽略值的剩余部分。让我们探讨如何以及为什么要使用这些模式。</p>
<!-- Old link, do not remove -->
<p><a id="ignoring-an-entire-value-with-_"></a></p>
<h4 id="使用-_-忽略整个值"><a class="header" href="#使用-_-忽略整个值">使用 <code>_</code> 忽略整个值</a></h4>
<p>我们已经使用下划线作为通配符模式，它将匹配任何值但不绑定到该值。这在 <code>match</code> 表达式的最后一个分支中特别有用，但我们也可以在任何模式中使用它，包括函数参数，如 Listing 19-17 所示。</p>
<figure class="listing">
<span class="file-name">Filename: src/main.rs</span>
<pre><pre class="playground"><code class="language-rust edition2024">fn foo(_: i32, y: i32) {
    println!("This code only uses the y parameter: {y}");
}

fn main() {
    foo(3, 4);
}</code></pre></pre>
<figcaption>Listing 19-17: 在函数签名中使用 <code>_</code></figcaption>
</figure>
<p>这段代码将完全忽略作为第一个参数传递的值 <code>3</code>，并打印 <code>This code only uses the y parameter: 4</code>。</p>
<p>在大多数情况下，当你不再需要某个特定的函数参数时，你会更改签名，使其不包含未使用的参数。忽略函数参数在某些情况下特别有用，例如，当你实现一个需要特定类型签名的 trait 时，但你的实现中的函数体不需要其中一个参数。然后你可以避免收到关于未使用函数参数的编译器警告，就像你使用名称时那样。</p>
<p><a id="ignoring-parts-of-a-value-with-a-nested-_"></a></p>
<h4 id="使用嵌套-_-忽略部分值"><a class="header" href="#使用嵌套-_-忽略部分值">使用嵌套 <code>_</code> 忽略部分值</a></h4>
<p>我们还可以在另一个模式中使用 <code>_</code> 来忽略值的部分，例如，当我们只想测试值的部分但不需要在相应的代码中使用其他部分时。Listing 19-18 显示了负责管理设置值的代码。业务要求是用户不应被允许覆盖设置的现有自定义值，但如果当前未设置，则可以取消设置并为其赋值。</p>
<figure class="listing">
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">fn main() {
</span>    let mut setting_value = Some(5);
    let new_setting_value = Some(10);

    match (setting_value, new_setting_value) {
        (Some(_), Some(_)) =&gt; {
            println!("Can't overwrite an existing customized value");
        }
        _ =&gt; {
            setting_value = new_setting_value;
        }
    }

    println!("setting is {setting_value:?}");
<span class="boring">}</span></code></pre></pre>
<figcaption>Listing 19-18: 在匹配 <code>Some</code> 变体的模式中使用下划线，当我们不需要使用 <code>Some</code> 内部的值时</figcaption>
</figure>
<p>这段代码将打印 <code>Can't overwrite an existing customized value</code>，然后打印 <code>setting is Some(5)</code>。在第一个匹配分支中，我们不需要匹配或使用 <code>Some</code> 变体中的值，但我们确实需要测试 <code>setting_value</code> 和 <code>new_setting_value</code> 都是 <code>Some</code> 变体的情况。在这种情况下，我们打印不更改 <code>setting_value</code> 的原因，并且它不会被更改。</p>
<p>在所有其他情况下（如果 <code>setting_value</code> 或 <code>new_setting_value</code> 是 <code>None</code>），由第二个分支中的 <code>_</code> 模式表示，我们希望允许 <code>new_setting_value</code> 成为 <code>setting_value</code>。</p>
<p>我们还可以在一个模式中的多个位置使用下划线来忽略特定值。Listing 19-19 展示了忽略五元素元组中的第二个和第四个值的示例。</p>
<figure class="listing">
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">fn main() {
</span>    let numbers = (2, 4, 8, 16, 32);

    match numbers {
        (first, _, third, _, fifth) =&gt; {
            println!("Some numbers: {first}, {third}, {fifth}");
        }
    }
<span class="boring">}</span></code></pre></pre>
<figcaption>Listing 19-19: 忽略元组的多个部分</figcaption>
</figure>
<p>这段代码将打印 <code>Some numbers: 2, 8, 32</code>，并且值 <code>4</code> 和 <code>16</code> 将被忽略。</p>
<!-- Old link, do not remove -->
<p><a id="ignoring-an-unused-variable-by-starting-its-name-with-_"></a></p>
<h4 id="通过以下划线开头的名称忽略未使用的变量"><a class="header" href="#通过以下划线开头的名称忽略未使用的变量">通过以下划线开头的名称忽略未使用的变量</a></h4>
<p>如果你创建了一个变量但没有在任何地方使用它，Rust 通常会发出警告，因为未使用的变量可能是一个错误。然而，有时能够创建一个你暂时不会使用的变量是有用的，例如当你进行原型设计或刚刚开始一个项目时。在这种情况下，你可以通过以下划线开头的变量名称告诉 Rust 不要警告你未使用的变量。在 Listing 19-20 中，我们创建了两个未使用的变量，但当我们编译这段代码时，我们应该只收到其中一个变量的警告。</p>
<figure class="listing">
<span class="file-name">Filename: src/main.rs</span>
<pre><pre class="playground"><code class="language-rust edition2024">fn main() {
    let _x = 5;
    let y = 10;
}</code></pre></pre>
<figcaption>Listing 19-20: 以下划线开头的变量名称以避免收到未使用变量的警告</figcaption>
</figure>
<p>在这里，我们收到了关于未使用变量 <code>y</code> 的警告，但没有收到关于未使用 <code>_x</code> 的警告。</p>
<p>请注意，仅使用 <code>_</code> 和使用以下划线开头的名称之间存在细微差别。语法 <code>_x</code> 仍然将值绑定到变量，而 <code>_</code> 根本不绑定。为了展示这种区别的重要性，Listing 19-21 将为我们提供一个错误。</p>
<figure class="listing">
<pre><code class="language-rust ignore does_not_compile"><span class="boring">fn main() {
</span>    let s = Some(String::from("Hello!"));

    if let Some(_s) = s {
        println!("found a string");
    }

    println!("{s:?}");
<span class="boring">}</span></code></pre>
<figcaption>Listing 19-21: 以下划线开头的未使用变量仍然绑定值，这可能会获取值的所有权</figcaption>
</figure>
<p>我们会收到一个错误，因为 <code>s</code> 值仍然会被移动到 <code>_s</code>，这阻止了我们再次使用 <code>s</code>。然而，单独使用下划线不会绑定到值。Listing 19-22 将编译而没有任何错误，因为 <code>s</code> 不会被移动到 <code>_</code>。</p>
<figure class="listing">
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">fn main() {
</span>    let s = Some(String::from("Hello!"));

    if let Some(_) = s {
        println!("found a string");
    }

    println!("{s:?}");
<span class="boring">}</span></code></pre></pre>
<figcaption>Listing 19-22: 使用下划线不会绑定值</figcaption>
</figure>
<p>这段代码可以正常工作，因为我们从未将 <code>s</code> 绑定到任何东西；它没有被移动。</p>
<p><a id="ignoring-remaining-parts-of-a-value-with-"></a></p>
<h4 id="使用--忽略值的剩余部分"><a class="header" href="#使用--忽略值的剩余部分">使用 <code>..</code> 忽略值的剩余部分</a></h4>
<p>对于具有多个部分的值，我们可以使用 <code>..</code> 语法来使用特定部分并忽略其余部分，避免为每个忽略的值列出下划线。<code>..</code> 模式忽略我们在模式的其余部分中未明确匹配的任何部分。在 Listing 19-23 中，我们有一个 <code>Point</code> 结构体，它保存了三维空间中的坐标。在 <code>match</code> 表达式中，我们只想操作 <code>x</code> 坐标并忽略 <code>y</code> 和 <code>z</code> 字段中的值。</p>
<figure class="listing">
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">fn main() {
</span>    struct Point {
        x: i32,
        y: i32,
        z: i32,
    }

    let origin = Point { x: 0, y: 0, z: 0 };

    match origin {
        Point { x, .. } =&gt; println!("x is {x}"),
    }
<span class="boring">}</span></code></pre></pre>
<figcaption>Listing 19-23: 使用 <code>..</code> 忽略 <code>Point</code> 的所有字段，除了 <code>x</code></figcaption>
</figure>
<p>我们列出了 <code>x</code> 值，然后只包含了 <code>..</code> 模式。这比必须列出 <code>y: _</code> 和 <code>z: _</code> 要快得多，特别是当我们在处理具有许多字段的结构体时，只有一两个字段是相关的。</p>
<p><code>..</code> 语法将根据需要扩展到尽可能多的值。Listing 19-24 展示了如何将 <code>..</code> 与元组一起使用。</p>
<figure class="listing">
<span class="file-name">Filename: src/main.rs</span>
<pre><pre class="playground"><code class="language-rust edition2024">fn main() {
    let numbers = (2, 4, 8, 16, 32);

    match numbers {
        (first, .., last) =&gt; {
            println!("Some numbers: {first}, {last}");
        }
    }
}</code></pre></pre>
<figcaption>Listing 19-24: 仅匹配元组中的第一个和最后一个值，并忽略所有其他值</figcaption>
</figure>
<p>在这段代码中，第一个和最后一个值分别与 <code>first</code> 和 <code>last</code> 匹配。<code>..</code> 将匹配并忽略中间的所有内容。</p>
<p>然而，使用 <code>..</code> 必须是无歧义的。如果不清楚哪些值用于匹配，哪些应该被忽略，Rust 会给我们一个错误。Listing 19-25 展示了以歧义方式使用 <code>..</code> 的示例，因此它不会编译。</p>
<figure class="listing">
<span class="file-name">Filename: src/main.rs</span>
<pre><code class="language-rust ignore does_not_compile">fn main() {
    let numbers = (2, 4, 8, 16, 32);

    match numbers {
        (.., second, ..) =&gt; {
            println!("Some numbers: {second}")
        },
    }
}</code></pre>
<figcaption>Listing 19-25: 尝试以歧义方式使用 <code>..</code></figcaption>
</figure>
<p>当我们编译这个示例时，我们会得到这个错误：</p>
<pre><code class="language-console">$ cargo run
   Compiling patterns v0.1.0 (file:///projects/patterns)
error: `..` can only be used once per tuple pattern
 --&gt; src/main.rs:5:22
  |
5 |         (.., second, ..) =&gt; {
  |          --          ^^ can only be used once per tuple pattern
  |          |
  |          previously used here

error: could not compile `patterns` (bin "patterns") due to 1 previous error
</code></pre>
<p>Rust 无法确定在匹配 <code>second</code> 之前要忽略元组中的多少个值，以及之后要忽略多少个值。这段代码可能意味着我们想忽略 <code>2</code>，将 <code>second</code> 绑定到 <code>4</code>，然后忽略 <code>8</code>、<code>16</code> 和 <code>32</code>；或者我们想忽略 <code>2</code> 和 <code>4</code>，将 <code>second</code> 绑定到 <code>8</code>，然后忽略 <code>16</code> 和 <code>32</code>；等等。变量名 <code>second</code> 对 Rust 没有任何特殊意义，因此我们得到一个编译器错误，因为在这种方式下使用 <code>..</code> 是歧义的。</p>
<h3 id="使用匹配守卫的额外条件"><a class="header" href="#使用匹配守卫的额外条件">使用匹配守卫的额外条件</a></h3>
<p><em>匹配守卫</em> 是一个额外的 <code>if</code> 条件，在 <code>match</code> 分支的模式之后指定，该条件也必须匹配才能选择该分支。匹配守卫对于表达比单独模式更复杂的想法非常有用。请注意，它们仅在 <code>match</code> 表达式中可用，而在 <code>if let</code> 或 <code>while let</code> 表达式中不可用。</p>
<p>条件可以使用模式中创建的变量。Listing 19-26 展示了一个 <code>match</code>，其中第一个分支的模式为 <code>Some(x)</code>，并且还有一个匹配守卫 <code>if x % 2 == 0</code>（如果数字是偶数，则为 <code>true</code>）。</p>
<figure class="listing">
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">fn main() {
</span>    let num = Some(4);

    match num {
        Some(x) if x % 2 == 0 =&gt; println!("The number {x} is even"),
        Some(x) =&gt; println!("The number {x} is odd"),
        None =&gt; (),
    }
<span class="boring">}</span></code></pre></pre>
<figcaption>Listing 19-26: 向模式添加匹配守卫</figcaption>
</figure>
<p>这个示例将打印 <code>The number 4 is even</code>。当 <code>num</code> 与第一个分支中的模式进行比较时，它匹配，因为 <code>Some(4)</code> 匹配 <code>Some(x)</code>。然后匹配守卫检查 <code>x</code> 除以 2 的余数是否等于 0，因为它是，所以选择了第一个分支。</p>
<p>如果 <code>num</code> 是 <code>Some(5)</code> 而不是 <code>Some(4)</code>，第一个分支中的匹配守卫将是 <code>false</code>，因为 5 除以 2 的余数是 1，不等于 0。Rust 将转到第二个分支，该分支匹配，因为第二个分支没有匹配守卫，因此匹配任何 <code>Some</code> 变体。</p>
<p>没有办法在模式中表达 <code>if x % 2 == 0</code> 条件，因此匹配守卫为我们提供了表达这种逻辑的能力。这种额外表达能力的缺点是，当涉及匹配守卫表达式时，编译器不会尝试检查穷尽性。</p>
<p>在 Listing 19-11 中，我们提到我们可以使用匹配守卫来解决我们的模式遮蔽问题。回想一下，我们在 <code>match</code> 表达式的模式中创建了一个新变量，而不是使用 <code>match</code> 外部的变量。这个新变量意味着我们无法测试外部变量的值。Listing 19-27 展示了我们如何使用匹配守卫来解决这个问题。</p>
<figure class="listing">
<span class="file-name">Filename: src/main.rs</span>
<pre><pre class="playground"><code class="language-rust edition2024">fn main() {
    let x = Some(5);
    let y = 10;

    match x {
        Some(50) =&gt; println!("Got 50"),
        Some(n) if n == y =&gt; println!("Matched, n = {n}"),
        _ =&gt; println!("Default case, x = {x:?}"),
    }

    println!("at the end: x = {x:?}, y = {y}");
}</code></pre></pre>
<figcaption>Listing 19-27: 使用匹配守卫测试与外部变量的相等性</figcaption>
</figure>
<p>这段代码现在将打印 <code>Default case, x = Some(5)</code>。第二个匹配分支中的模式没有引入一个会遮蔽外部 <code>y</code> 的新变量 <code>y</code>，这意味着我们可以在匹配守卫中使用外部 <code>y</code>。我们没有将模式指定为 <code>Some(y)</code>，这会遮蔽外部 <code>y</code>，而是指定为 <code>Some(n)</code>。这创建了一个新变量 <code>n</code>，它不会遮蔽任何东西，因为外部没有 <code>n</code> 变量。</p>
<p>匹配守卫 <code>if n == y</code> 不是一个模式，因此不会引入新变量。这个 <code>y</code> <em>是</em> 外部的 <code>y</code> 而不是遮蔽它的新 <code>y</code>，我们可以通过比较 <code>n</code> 和 <code>y</code> 来查找与外部 <code>y</code> 具有相同值的值。</p>
<p>你还可以在匹配守卫中使用 <em>或</em> 运算符 <code>|</code> 来指定多个模式；匹配守卫条件将应用于所有模式。Listing 19-28 展示了将使用 <code>|</code> 的模式与匹配守卫结合时的优先级。这个示例的重要部分是 <code>if y</code> 匹配守卫适用于 <code>4</code>、<code>5</code> <em>和</em> <code>6</code>，即使看起来 <code>if y</code> 只适用于 <code>6</code>。</p>
<figure class="listing">
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">fn main() {
</span>    let x = 4;
    let y = false;

    match x {
        4 | 5 | 6 if y =&gt; println!("yes"),
        _ =&gt; println!("no"),
    }
<span class="boring">}</span></code></pre></pre>
<figcaption>Listing 19-28: 将多个模式与匹配守卫结合</figcaption>
</figure>
<p>匹配条件规定，只有当 <code>x</code> 的值等于 <code>4</code>、<code>5</code> 或 <code>6</code> <em>并且</em> <code>y</code> 为 <code>true</code> 时，该分支才匹配。当这段代码运行时，第一个分支的模式匹配，因为 <code>x</code> 是 <code>4</code>，但匹配守卫 <code>if y</code> 是 <code>false</code>，因此第一个分支未被选择。代码继续到第二个分支，该分支匹配，因此程序打印 <code>no</code>。原因是 <code>if</code> 条件适用于整个模式 <code>4 | 5 | 6</code>，而不仅仅是最后一个值 <code>6</code>。换句话说，匹配守卫相对于模式的优先级行为如下：</p>
<pre><code class="language-text">(4 | 5 | 6) if y =&gt; ...
</code></pre>
<p>而不是：</p>
<pre><code class="language-text">4 | 5 | (6 if y) =&gt; ...
</code></pre>
<p>运行代码后，优先级行为显而易见：如果匹配守卫仅适用于使用 <code>|</code> 运算符指定的值列表中的最后一个值，则该分支将匹配，程序将打印 <code>yes</code>。</p>
<h3 id="-绑定"><a class="header" href="#-绑定"><code>@</code> 绑定</a></h3>
<p><em>at</em> 运算符 <code>@</code> 允许我们在测试值是否匹配模式的同时创建一个变量来保存该值。在 Listing 19-29 中，我们想测试 <code>Message::Hello</code> 的 <code>id</code> 字段是否在 <code>3..=7</code> 范围内。我们还希望将该值绑定到变量 <code>id_variable</code>，以便我们可以在与该分支相关的代码中使用它。我们可以将这个变量命名为 <code>id</code>，与字段同名，但在这个示例中，我们将使用不同的名称。</p>
<figure class="listing">
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">fn main() {
</span>    enum Message {
        Hello { id: i32 },
    }

    let msg = Message::Hello { id: 5 };

    match msg {
        Message::Hello {
            id: id_variable @ 3..=7,
        } =&gt; println!("Found an id in range: {id_variable}"),
        Message::Hello { id: 10..=12 } =&gt; {
            println!("Found an id in another range")
        }
        Message::Hello { id } =&gt; println!("Found some other id: {id}"),
    }
<span class="boring">}</span></code></pre></pre>
<figcaption>Listing 19-29: 使用 <code>@</code> 在模式中绑定值的同时测试它</figcaption>
</figure>
<p>这个示例将打印 <code>Found an id in range: 5</code>。通过在范围 <code>3..=7</code> 之前指定 <code>id_variable @</code>，我们捕获了匹配该范围的任何值，同时测试该值是否匹配范围模式。</p>
<p>在第二个分支中，我们只在模式中指定了一个范围，与该分支相关的代码没有包含 <code>id</code> 字段实际值的变量。<code>id</code> 字段的值可能是 10、11 或 12，但与该模式相关的代码不知道它是哪一个。模式代码无法使用 <code>id</code> 字段的值，因为我们没有将 <code>id</code> 值保存在变量中。</p>
<p>在最后一个分支中，我们指定了一个没有范围的变量，我们确实有一个变量 <code>id</code> 可以在该分支的代码中使用。原因是我们使用了结构体字段简写语法。但我们没有像前两个分支那样对 <code>id</code> 字段中的值应用任何测试：任何值都会匹配这个模式。</p>
<p>使用 <code>@</code> 让我们可以在一个模式中测试一个值并将其保存在变量中。</p>
<h2 id="总结"><a class="header" href="#总结">总结</a></h2>
<p>Rust 的模式在区分不同类型的数据时非常有用。当在 <code>match</code> 表达式中使用时，Rust 确保你的模式涵盖了所有可能的值，否则你的程序将无法编译。<code>let</code> 语句和函数参数中的模式使这些结构更有用，能够在将值分解为较小部分的同时将这些部分分配给变量。我们可以创建简单或复杂的模式来满足我们的需求。</p>
<p>接下来，作为本书的倒数第二章，我们将看看 Rust 各种功能的一些高级方面。</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="ch19-02-refutability.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="ch20-00-advanced-features.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="ch19-02-refutability.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="ch20-00-advanced-features.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->
        <script src="ferris.js"></script>


    </div>
    </body>
</html>
