<!DOCTYPE HTML>
<html lang="en" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>使用字符串存储 UTF-8 编码的文本 - Rust编程语言</title>


        <!-- Custom HTML head -->

        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" id="highlight-css" href="highlight.css">
        <link rel="stylesheet" id="tomorrow-night-css" href="tomorrow-night.css">
        <link rel="stylesheet" id="ayu-highlight-css" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="ferris.css">
        <link rel="stylesheet" href="theme/2018-edition.css">
        <link rel="stylesheet" href="theme/semantic-notes.css">
        <link rel="stylesheet" href="theme/listing.css">


        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="toc.js"></script>
    </head>
    <body>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var sidebar = null;
            var sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Rust编程语言</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/lxqddd/rust-book-cn" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h2 id="使用字符串存储-utf-8-编码的文本"><a class="header" href="#使用字符串存储-utf-8-编码的文本">使用字符串存储 UTF-8 编码的文本</a></h2>
<p>我们在第 4 章讨论过字符串，但现在我们将更深入地探讨它们。新 Rustacean 通常会在字符串上遇到困难，原因有三：Rust 倾向于暴露可能的错误、字符串是一种比许多程序员认为的更复杂的数据结构，以及 UTF-8。这些因素结合在一起，可能会让你从其他编程语言转过来时感到困难。</p>
<p>我们在集合的上下文中讨论字符串，因为字符串是作为字节集合实现的，再加上一些方法，以便在将这些字节解释为文本时提供有用的功能。在本节中，我们将讨论每个集合类型都有的 <code>String</code> 操作，例如创建、更新和读取。我们还将讨论 <code>String</code> 与其他集合的不同之处，即由于人和计算机对 <code>String</code> 数据的解释方式不同，索引到 <code>String</code> 中会变得复杂。</p>
<h3 id="什么是字符串"><a class="header" href="#什么是字符串">什么是字符串？</a></h3>
<p>我们首先定义术语 <em>字符串</em> 的含义。Rust 在核心语言中只有一种字符串类型，即字符串切片 <code>str</code>，通常以借用的形式 <code>&amp;str</code> 出现。在第 4 章中，我们讨论了 <em>字符串切片</em>，它们是对存储在其他地方的某些 UTF-8 编码字符串数据的引用。例如，字符串字面量存储在程序的二进制文件中，因此它们是字符串切片。</p>
<p><code>String</code> 类型由 Rust 的标准库提供，而不是编码在核心语言中，它是一种可增长、可变、拥有所有权的 UTF-8 编码字符串类型。当 Rustacean 在 Rust 中提到“字符串”时，他们可能指的是 <code>String</code> 或字符串切片 <code>&amp;str</code> 类型，而不仅仅是其中一种类型。尽管本节主要讨论 <code>String</code>，但这两种类型在 Rust 的标准库中都被大量使用，并且 <code>String</code> 和字符串切片都是 UTF-8 编码的。</p>
<h3 id="创建一个新的字符串"><a class="header" href="#创建一个新的字符串">创建一个新的字符串</a></h3>
<p>许多与 <code>Vec&lt;T&gt;</code> 相同的操作也适用于 <code>String</code>，因为 <code>String</code> 实际上是作为字节向量的包装器实现的，具有一些额外的保证、限制和功能。一个与 <code>Vec&lt;T&gt;</code> 和 <code>String</code> 工作方式相同的函数是用于创建实例的 <code>new</code> 函数，如 Listing 8-11 所示。</p>
<figure class="listing">
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">fn main() {
</span>    let mut s = String::new();
<span class="boring">}</span></code></pre></pre>
<figcaption>Listing 8-11: 创建一个新的空 <code>String</code></figcaption>
</figure>
<p>这行代码创建了一个名为 <code>s</code> 的新空字符串，我们可以随后将数据加载到其中。通常，我们会有一些初始数据，我们希望用它来启动字符串。为此，我们使用 <code>to_string</code> 方法，该方法可用于任何实现了 <code>Display</code> trait 的类型，就像字符串字面量一样。Listing 8-12 展示了两个示例。</p>
<figure class="listing">
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">fn main() {
</span>    let data = "initial contents";

    let s = data.to_string();

    // The method also works on a literal directly:
    let s = "initial contents".to_string();
<span class="boring">}</span></code></pre></pre>
<figcaption>Listing 8-12: 使用 <code>to_string</code> 方法从字符串字面量创建 <code>String</code></figcaption>
</figure>
<p>这段代码创建了一个包含 <code>initial contents</code> 的字符串。</p>
<p>我们还可以使用 <code>String::from</code> 函数从字符串字面量创建 <code>String</code>。Listing 8-13 中的代码与 Listing 8-12 中使用 <code>to_string</code> 的代码等效。</p>
<figure class="listing">
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">fn main() {
</span>    let s = String::from("initial contents");
<span class="boring">}</span></code></pre></pre>
<figcaption>Listing 8-13: 使用 <code>String::from</code> 函数从字符串字面量创建 <code>String</code></figcaption>
</figure>
<p>因为字符串用于许多事情，所以我们可以使用许多不同的通用 API 来处理字符串，这为我们提供了很多选择。其中一些可能看起来冗余，但它们都有其用途！在这种情况下，<code>String::from</code> 和 <code>to_string</code> 做同样的事情，所以你选择哪一个取决于风格和可读性。</p>
<p>记住，字符串是 UTF-8 编码的，所以我们可以在其中包含任何正确编码的数据，如 Listing 8-14 所示。</p>
<figure class="listing">
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">fn main() {
</span>    let hello = String::from("السلام عليكم");
    let hello = String::from("Dobrý den");
    let hello = String::from("Hello");
    let hello = String::from("שלום");
    let hello = String::from("नमस्ते");
    let hello = String::from("こんにちは");
    let hello = String::from("안녕하세요");
    let hello = String::from("你好");
    let hello = String::from("Olá");
    let hello = String::from("Здравствуйте");
    let hello = String::from("Hola");
<span class="boring">}</span></code></pre></pre>
<figcaption>Listing 8-14: 在不同语言的字符串中存储问候语</figcaption>
</figure>
<p>所有这些都是有效的 <code>String</code> 值。</p>
<h3 id="更新字符串"><a class="header" href="#更新字符串">更新字符串</a></h3>
<p><code>String</code> 可以增长大小，其内容可以更改，就像 <code>Vec&lt;T&gt;</code> 的内容一样，如果你向其中推送更多数据。此外，你可以方便地使用 <code>+</code> 运算符或 <code>format!</code> 宏来连接 <code>String</code> 值。</p>
<h4 id="使用-push_str-和-push-追加到字符串"><a class="header" href="#使用-push_str-和-push-追加到字符串">使用 <code>push_str</code> 和 <code>push</code> 追加到字符串</a></h4>
<p>我们可以使用 <code>push_str</code> 方法追加一个字符串切片来增长 <code>String</code>，如 Listing 8-15 所示。</p>
<figure class="listing">
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">fn main() {
</span>    let mut s = String::from("foo");
    s.push_str("bar");
<span class="boring">}</span></code></pre></pre>
<figcaption>Listing 8-15: 使用 <code>push_str</code> 方法将字符串切片追加到 <code>String</code></figcaption>
</figure>
<p>在这两行之后，<code>s</code> 将包含 <code>foobar</code>。<code>push_str</code> 方法接受一个字符串切片，因为我们不一定想要获取参数的所有权。例如，在 Listing 8-16 的代码中，我们希望在将其内容追加到 <code>s1</code> 后仍然能够使用 <code>s2</code>。</p>
<figure class="listing">
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">fn main() {
</span>    let mut s1 = String::from("foo");
    let s2 = "bar";
    s1.push_str(s2);
    println!("s2 is {s2}");
<span class="boring">}</span></code></pre></pre>
<figcaption>Listing 8-16: 在将其内容追加到 <code>String</code> 后使用字符串切片</figcaption>
</figure>
<p>如果 <code>push_str</code> 方法获取了 <code>s2</code> 的所有权，我们将无法在最后一行打印其值。然而，这段代码按预期工作！</p>
<p><code>push</code> 方法接受一个字符作为参数并将其添加到 <code>String</code> 中。Listing 8-17 使用 <code>push</code> 方法将字母 <em>l</em> 添加到 <code>String</code> 中。</p>
<figure class="listing">
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">fn main() {
</span>    let mut s = String::from("lo");
    s.push('l');
<span class="boring">}</span></code></pre></pre>
<figcaption>Listing 8-17: 使用 <code>push</code> 方法向 <code>String</code> 值添加一个字符</figcaption>
</figure>
<p>结果，<code>s</code> 将包含 <code>lol</code>。</p>
<h4 id="使用--运算符或-format-宏进行连接"><a class="header" href="#使用--运算符或-format-宏进行连接">使用 <code>+</code> 运算符或 <code>format!</code> 宏进行连接</a></h4>
<p>通常，你会想要组合两个现有的字符串。一种方法是使用 <code>+</code> 运算符，如 Listing 8-18 所示。</p>
<figure class="listing">
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">fn main() {
</span>    let s1 = String::from("Hello, ");
    let s2 = String::from("world!");
    let s3 = s1 + &amp;s2; // note s1 has been moved here and can no longer be used
<span class="boring">}</span></code></pre></pre>
<figcaption>Listing 8-18: 使用 <code>+</code> 运算符将两个 <code>String</code> 值组合成一个新的 <code>String</code> 值</figcaption>
</figure>
<p>字符串 <code>s3</code> 将包含 <code>Hello, world!</code>。<code>s1</code> 在加法后不再有效的原因，以及我们使用 <code>s2</code> 的引用的原因，与我们在使用 <code>+</code> 运算符时调用的方法的签名有关。<code>+</code> 运算符使用 <code>add</code> 方法，其签名如下所示：</p>
<pre><code class="language-rust ignore">fn add(self, s: &amp;str) -&gt; String {</code></pre>
<p>在标准库中，你会看到 <code>add</code> 使用泛型和关联类型定义。在这里，我们替换了具体类型，这是当我们使用 <code>String</code> 值调用此方法时发生的情况。我们将在第 10 章讨论泛型。这个签名为我们提供了理解 <code>+</code> 运算符复杂部分所需的线索。</p>
<p>首先，<code>s2</code> 有一个 <code>&amp;</code>，意味着我们将第二个字符串的 <em>引用</em> 添加到第一个字符串。这是因为 <code>add</code> 函数中的 <code>s</code> 参数：我们只能将 <code>&amp;str</code> 添加到 <code>String</code>；我们不能将两个 <code>String</code> 值加在一起。但是等等——<code>&amp;s2</code> 的类型是 <code>&amp;String</code>，而不是 <code>&amp;str</code>，正如 <code>add</code> 的第二个参数所指定的那样。那么为什么 Listing 8-18 能够编译通过呢？</p>
<p>我们能够在 <code>add</code> 调用中使用 <code>&amp;s2</code> 的原因是编译器可以将 <code>&amp;String</code> 参数强制转换为 <code>&amp;str</code>。当我们调用 <code>add</code> 方法时，Rust 使用了一个 <em>解引用强制转换</em>，在这里将 <code>&amp;s2</code> 转换为 <code>&amp;s2[..]</code>。我们将在第 15 章更深入地讨论解引用强制转换。因为 <code>add</code> 不获取 <code>s</code> 参数的所有权，<code>s2</code> 在此操作后仍然是一个有效的 <code>String</code>。</p>
<p>其次，我们可以在签名中看到 <code>add</code> 获取了 <code>self</code> 的所有权，因为 <code>self</code> 没有 <code>&amp;</code>。这意味着 Listing 8-18 中的 <code>s1</code> 将被移动到 <code>add</code> 调用中，并且在之后不再有效。因此，尽管 <code>let s3 = s1 + &amp;s2;</code> 看起来像是会复制两个字符串并创建一个新的字符串，但实际上这个语句获取了 <code>s1</code> 的所有权，追加了 <code>s2</code> 内容的副本，然后返回结果的所有权。换句话说，它看起来像是做了很多复制，但实际上并没有；实现比复制更高效。</p>
<p>如果我们需要连接多个字符串，<code>+</code> 运算符的行为会变得笨拙：</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">fn main() {
</span>    let s1 = String::from("tic");
    let s2 = String::from("tac");
    let s3 = String::from("toe");

    let s = s1 + "-" + &amp;s2 + "-" + &amp;s3;
<span class="boring">}</span></code></pre></pre>
<p>此时，<code>s</code> 将是 <code>tic-tac-toe</code>。由于所有的 <code>+</code> 和 <code>"</code> 字符，很难看出发生了什么。对于更复杂的字符串组合，我们可以使用 <code>format!</code> 宏：</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">fn main() {
</span>    let s1 = String::from("tic");
    let s2 = String::from("tac");
    let s3 = String::from("toe");

    let s = format!("{s1}-{s2}-{s3}");
<span class="boring">}</span></code></pre></pre>
<p>这段代码也将 <code>s</code> 设置为 <code>tic-tac-toe</code>。<code>format!</code> 宏的工作方式类似于 <code>println!</code>，但它不是将输出打印到屏幕上，而是返回一个包含内容的 <code>String</code>。使用 <code>format!</code> 的代码版本更容易阅读，并且 <code>format!</code> 宏生成的代码使用引用，因此此调用不会获取其任何参数的所有权。</p>
<h3 id="字符串索引"><a class="header" href="#字符串索引">字符串索引</a></h3>
<p>在许多其他编程语言中，通过索引引用字符串中的单个字符是一种有效且常见的操作。然而，如果你尝试在 Rust 中使用索引语法访问 <code>String</code> 的部分内容，你会得到一个错误。考虑 Listing 8-19 中的无效代码。</p>
<figure class="listing">
<pre><code class="language-rust ignore does_not_compile"><span class="boring">fn main() {
</span>    let s1 = String::from("hi");
    let h = s1[0];
<span class="boring">}</span></code></pre>
<figcaption>Listing 8-19: 尝试使用索引语法访问 String</figcaption>
</figure>
<p>这段代码将导致以下错误：</p>
<pre><code class="language-console">$ cargo run
   Compiling collections v0.1.0 (file:///projects/collections)
error[E0277]: the type `str` cannot be indexed by `{integer}`
 --&gt; src/main.rs:3:16
  |
3 |     let h = s1[0];
  |                ^ string indices are ranges of `usize`
  |
  = note: you can use `.chars().nth()` or `.bytes().nth()`
          for more information, see chapter 8 in The Book: &lt;https://doc.rust-lang.org/book/ch08-02-strings.html#indexing-into-strings&gt;
  = help: the trait `SliceIndex&lt;str&gt;` is not implemented for `{integer}`
          but trait `SliceIndex&lt;[_]&gt;` is implemented for `usize`
  = help: for that trait implementation, expected `[_]`, found `str`
  = note: required for `String` to implement `Index&lt;{integer}&gt;`

For more information about this error, try `rustc --explain E0277`.
error: could not compile `collections` (bin "collections") due to 1 previous error
</code></pre>
<p>错误和说明告诉我们：Rust 字符串不支持索引。但为什么不支持呢？要回答这个问题，我们需要讨论 Rust 如何在内存中存储字符串。</p>
<h4 id="内部表示"><a class="header" href="#内部表示">内部表示</a></h4>
<p><code>String</code> 是 <code>Vec&lt;u8&gt;</code> 的包装器。让我们看看 Listing 8-14 中一些正确编码的 UTF-8 示例字符串。首先，这个：</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">fn main() {
</span><span class="boring">    let hello = String::from("السلام عليكم");
</span><span class="boring">    let hello = String::from("Dobrý den");
</span><span class="boring">    let hello = String::from("Hello");
</span><span class="boring">    let hello = String::from("שלום");
</span><span class="boring">    let hello = String::from("नमस्ते");
</span><span class="boring">    let hello = String::from("こんにちは");
</span><span class="boring">    let hello = String::from("안녕하세요");
</span><span class="boring">    let hello = String::from("你好");
</span><span class="boring">    let hello = String::from("Olá");
</span><span class="boring">    let hello = String::from("Здравствуйте");
</span>    let hello = String::from("Hola");
<span class="boring">}</span></code></pre></pre>
<p>在这种情况下，<code>len</code> 将是 <code>4</code>，这意味着存储字符串 <code>"Hola"</code> 的向量长度为 4 字节。这些字母在 UTF-8 编码中每个占用一个字节。然而，以下行可能会让你感到惊讶（注意这个字符串以大写西里尔字母 <em>Ze</em> 开头，而不是数字 3）：</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">fn main() {
</span><span class="boring">    let hello = String::from("السلام عليكم");
</span><span class="boring">    let hello = String::from("Dobrý den");
</span><span class="boring">    let hello = String::from("Hello");
</span><span class="boring">    let hello = String::from("שלום");
</span><span class="boring">    let hello = String::from("नमस्ते");
</span><span class="boring">    let hello = String::from("こんにちは");
</span><span class="boring">    let hello = String::from("안녕하세요");
</span><span class="boring">    let hello = String::from("你好");
</span><span class="boring">    let hello = String::from("Olá");
</span>    let hello = String::from("Здравствуйте");
<span class="boring">    let hello = String::from("Hola");
</span><span class="boring">}</span></code></pre></pre>
<p>如果你被问到字符串的长度是多少，你可能会说 12。事实上，Rust 的答案是 24：这是 UTF-8 编码“Здравствуйте”所需的字节数，因为该字符串中的每个 Unicode 标量值占用 2 字节的存储空间。因此，字符串字节的索引并不总是与有效的 Unicode 标量值相关联。为了演示，考虑以下无效的 Rust 代码：</p>
<pre><code class="language-rust ignore does_not_compile">let hello = "Здравствуйте";
let answer = &amp;hello[0];</code></pre>
<p>你已经知道 <code>answer</code> 不会是 <code>З</code>，第一个字母。当用 UTF-8 编码时，<code>З</code> 的第一个字节是 <code>208</code>，第二个字节是 <code>151</code>，所以 <code>answer</code> 实际上应该是 <code>208</code>，但 <code>208</code> 本身并不是一个有效的字符。返回 <code>208</code> 可能不是用户想要的，如果他们要求这个字符串的第一个字母；然而，这是 Rust 在字节索引 0 处唯一拥有的数据。用户通常不希望返回字节值，即使字符串只包含拉丁字母：如果 <code>&amp;"hi"[0]</code> 是返回字节值的有效代码，它将返回 <code>104</code>，而不是 <code>h</code>。</p>
<p>因此，答案是为了避免返回意外值并导致可能不会立即发现的错误，Rust 根本不编译此代码，并在开发过程的早期防止误解。</p>
<h4 id="字节标量值和字素簇哦天哪"><a class="header" href="#字节标量值和字素簇哦天哪">字节、标量值和字素簇！哦，天哪！</a></h4>
<p>关于 UTF-8 的另一点是，实际上有三种相关的方式可以从 Rust 的角度来看待字符串：作为字节、标量值和字素簇（最接近我们称之为 <em>字母</em> 的东西）。</p>
<p>如果我们看一下用天城文书写的印地语单词“नमस्ते”，它存储为一个 <code>u8</code> 值的向量，看起来像这样：</p>
<pre><code class="language-text">[224, 164, 168, 224, 164, 174, 224, 164, 184, 224, 165, 141, 224, 164, 164,
224, 165, 135]
</code></pre>
<p>这是 18 字节，是计算机最终存储这些数据的方式。如果我们把它们看作 Unicode 标量值，也就是 Rust 的 <code>char</code> 类型，这些字节看起来像这样：</p>
<pre><code class="language-text">['न', 'म', 'स', '्', 'त', 'े']
</code></pre>
<p>这里有六个 <code>char</code> 值，但第四个和第六个不是字母：它们是单独没有意义的变音符号。最后，如果我们把它们看作字素簇，我们会得到一个人称之为组成印地语单词的四个字母：</p>
<pre><code class="language-text">["न", "म", "स्", "ते"]
</code></pre>
<p>Rust 提供了不同的方式来解释计算机存储的原始字符串数据，以便每个程序可以选择它需要的解释，无论数据是哪种人类语言。</p>
<p>Rust 不允许我们通过索引 <code>String</code> 来获取字符的最后一个原因是，索引操作预期总是以恒定时间（O(1)）完成。但是，对于 <code>String</code> 来说，无法保证这种性能，因为 Rust 必须从头开始遍历内容到索引，以确定有多少有效字符。</p>
<h3 id="字符串切片"><a class="header" href="#字符串切片">字符串切片</a></h3>
<p>索引到字符串中通常不是一个好主意，因为不清楚字符串索引操作的返回类型应该是什么：字节值、字符、字素簇还是字符串切片。因此，如果你确实需要使用索引来创建字符串切片，Rust 要求你更加明确。</p>
<p>你可以使用带有范围的 <code>[]</code> 来创建包含特定字节的字符串切片，而不是使用带有单个数字的 <code>[]</code>：</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let hello = "Здравствуйте";

let s = &amp;hello[0..4];
<span class="boring">}</span></code></pre></pre>
<p>在这里，<code>s</code> 将是一个包含字符串前四个字节的 <code>&amp;str</code>。之前我们提到，这些字符中的每一个都是两个字节，这意味着 <code>s</code> 将是 <code>Зд</code>。</p>
<p>如果我们尝试只切片一个字符的部分字节，比如 <code>&amp;hello[0..1]</code>，Rust 会在运行时 panic，就像在向量中访问无效索引一样：</p>
<pre><code class="language-console">$ cargo run
   Compiling collections v0.1.0 (file:///projects/collections)
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.43s
     Running `target/debug/collections`

thread 'main' panicked at src/main.rs:4:19:
byte index 1 is not a char boundary; it is inside 'З' (bytes 0..2) of `Здравствуйте`
note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace
</code></pre>
<p>在使用范围创建字符串切片时应该小心，因为这样做可能会导致程序崩溃。</p>
<h3 id="遍历字符串的方法"><a class="header" href="#遍历字符串的方法">遍历字符串的方法</a></h3>
<p>操作字符串片段的最佳方式是明确你是想要字符还是字节。对于单个 Unicode 标量值，使用 <code>chars</code> 方法。在“Зд”上调用 <code>chars</code> 会分离并返回两个 <code>char</code> 类型的值，你可以遍历结果以访问每个元素：</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>for c in "Зд".chars() {
    println!("{c}");
}
<span class="boring">}</span></code></pre></pre>
<p>这段代码将打印以下内容：</p>
<pre><code class="language-text">З
д
</code></pre>
<p>或者，<code>bytes</code> 方法返回每个原始字节，这可能适合你的领域：</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>for b in "Зд".bytes() {
    println!("{b}");
}
<span class="boring">}</span></code></pre></pre>
<p>这段代码将打印组成此字符串的四个字节：</p>
<pre><code class="language-text">208
151
208
180
</code></pre>
<p>但请记住，有效的 Unicode 标量值可能由多个字节组成。</p>
<p>从字符串中获取字素簇，如天城文脚本，是复杂的，因此标准库不提供此功能。如果你需要此功能，可以在 <a href="https://crates.io/">crates.io</a> 上找到可用的 crate。</p>
<h3 id="字符串并不简单"><a class="header" href="#字符串并不简单">字符串并不简单</a></h3>
<p>总结一下，字符串是复杂的。不同的编程语言对如何向程序员展示这种复杂性做出了不同的选择。Rust 选择将所有 Rust 程序的默认行为设置为正确处理 <code>String</code> 数据，这意味着程序员必须提前更多地考虑如何处理 UTF-8 数据。这种权衡暴露了字符串的复杂性，这在其他编程语言中并不明显，但它可以防止你在开发周期的后期处理涉及非 ASCII 字符的错误。</p>
<p>好消息是，标准库提供了许多基于 <code>String</code> 和 <code>&amp;str</code> 类型的功能，以帮助正确处理这些复杂情况。请务必查看文档，了解有用的方法，如 <code>contains</code> 用于在字符串中搜索，以及 <code>replace</code> 用于将字符串的一部分替换为另一个字符串。</p>
<p>让我们转向一些不那么复杂的东西：哈希映射！</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="ch08-01-vectors.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="ch08-03-hash-maps.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="ch08-01-vectors.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="ch08-03-hash-maps.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->
        <script src="ferris.js"></script>


    </div>
    </body>
</html>
