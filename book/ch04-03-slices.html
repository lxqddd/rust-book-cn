<!DOCTYPE HTML>
<html lang="en" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>切片类型 - Rust编程语言</title>


        <!-- Custom HTML head -->

        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" id="highlight-css" href="highlight.css">
        <link rel="stylesheet" id="tomorrow-night-css" href="tomorrow-night.css">
        <link rel="stylesheet" id="ayu-highlight-css" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="ferris.css">
        <link rel="stylesheet" href="theme/2018-edition.css">
        <link rel="stylesheet" href="theme/semantic-notes.css">
        <link rel="stylesheet" href="theme/listing.css">


        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="toc.js"></script>
    </head>
    <body>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var sidebar = null;
            var sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Rust编程语言</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/lxqddd/rust-book-cn" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h2 id="切片类型"><a class="header" href="#切片类型">切片类型</a></h2>
<p><em>切片</em> 允许你引用一个集合中的连续元素序列，而不是整个集合。切片是一种引用，因此它没有所有权。</p>
<p>这里有一个小的编程问题：编写一个函数，该函数接受一个由空格分隔的单词字符串，并返回该字符串中的第一个单词。如果函数在字符串中没有找到空格，那么整个字符串必须是一个单词，因此应该返回整个字符串。</p>
<p>让我们通过编写这个函数的签名来了解切片将解决的问题，而不使用切片：</p>
<pre><code class="language-rust ignore">fn first_word(s: &amp;String) -&gt; ?</code></pre>
<p><code>first_word</code> 函数有一个 <code>&amp;String</code> 作为参数。我们不需要所有权，所以这没问题。（在惯用的 Rust 中，函数不会获取其参数的所有权，除非它们需要，随着我们继续深入，这一点会变得更加清晰！）但是我们应该返回什么？我们实际上没有办法谈论字符串的一部分。然而，我们可以返回单词末尾的索引，由空格表示。让我们尝试一下，如 Listing 4-7 所示。</p>
<figure class="listing">
<span class="file-name">Filename: src/main.rs</span>
<pre><pre class="playground"><code class="language-rust edition2024">fn first_word(s: &amp;String) -&gt; usize {
    let bytes = s.as_bytes();

    for (i, &amp;item) in bytes.iter().enumerate() {
        if item == b' ' {
            return i;
        }
    }

    s.len()
}
<span class="boring">
</span><span class="boring">fn main() {}</span></code></pre></pre>
<figcaption>Listing 4-7: 返回 <code>String</code> 参数中字节索引值的 <code>first_word</code> 函数</figcaption>
</figure>
<p>因为我们需要逐个元素地遍历 <code>String</code> 并检查某个值是否为空格，所以我们将使用 <code>as_bytes</code> 方法将 <code>String</code> 转换为字节数组。</p>
<pre><code class="language-rust ignore"><span class="boring">fn first_word(s: &amp;String) -&gt; usize {
</span>    let bytes = s.as_bytes();
<span class="boring">
</span><span class="boring">    for (i, &amp;item) in bytes.iter().enumerate() {
</span><span class="boring">        if item == b' ' {
</span><span class="boring">            return i;
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    s.len()
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn main() {}</span></code></pre>
<p>接下来，我们使用 <code>iter</code> 方法在字节数组上创建一个迭代器：</p>
<pre><code class="language-rust ignore"><span class="boring">fn first_word(s: &amp;String) -&gt; usize {
</span><span class="boring">    let bytes = s.as_bytes();
</span><span class="boring">
</span>    for (i, &amp;item) in bytes.iter().enumerate() {
<span class="boring">        if item == b' ' {
</span><span class="boring">            return i;
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    s.len()
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn main() {}</span></code></pre>
<p>我们将在 <a href="ch13-02-iterators.html">第 13 章</a><!-- ignore --> 中更详细地讨论迭代器。现在，只需知道 <code>iter</code> 是一个返回集合中每个元素的方法，而 <code>enumerate</code> 包装了 <code>iter</code> 的结果，并将每个元素作为元组的一部分返回。<code>enumerate</code> 返回的元组的第一个元素是索引，第二个元素是对元素的引用。这比我们自己计算索引更方便。</p>
<p>因为 <code>enumerate</code> 方法返回一个元组，我们可以使用模式来解构这个元组。我们将在 <a href="ch06-02-match.html#patterns-that-bind-to-values">第 6 章</a><!-- ignore --> 中更详细地讨论模式。在 <code>for</code> 循环中，我们指定一个模式，其中 <code>i</code> 是元组中的索引，<code>&amp;item</code> 是元组中的单个字节。因为我们从 <code>.iter().enumerate()</code> 中获取了对元素的引用，所以我们在模式中使用 <code>&amp;</code>。</p>
<p>在 <code>for</code> 循环内部，我们使用字节字面量语法搜索表示空格的字节。如果我们找到一个空格，我们返回该位置。否则，我们使用 <code>s.len()</code> 返回字符串的长度。</p>
<pre><code class="language-rust ignore"><span class="boring">fn first_word(s: &amp;String) -&gt; usize {
</span><span class="boring">    let bytes = s.as_bytes();
</span><span class="boring">
</span><span class="boring">    for (i, &amp;item) in bytes.iter().enumerate() {
</span>        if item == b' ' {
            return i;
        }
    }

    s.len()
<span class="boring">}
</span><span class="boring">
</span><span class="boring">fn main() {}</span></code></pre>
<p>我们现在有一种方法可以找到字符串中第一个单词的结尾索引，但有一个问题。我们返回的是一个单独的 <code>usize</code>，但它只在 <code>&amp;String</code> 的上下文中有意义。换句话说，因为它是一个与 <code>String</code> 分离的值，所以不能保证它在将来仍然有效。考虑 Listing 4-8 中的程序，它使用了 Listing 4-7 中的 <code>first_word</code> 函数。</p>
<figure class="listing">
<span class="file-name">Filename: src/main.rs</span>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">fn first_word(s: &amp;String) -&gt; usize {
</span><span class="boring">    let bytes = s.as_bytes();
</span><span class="boring">
</span><span class="boring">    for (i, &amp;item) in bytes.iter().enumerate() {
</span><span class="boring">        if item == b' ' {
</span><span class="boring">            return i;
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    s.len()
</span><span class="boring">}
</span><span class="boring">
</span>fn main() {
    let mut s = String::from("hello world");

    let word = first_word(&amp;s); // word will get the value 5

    s.clear(); // this empties the String, making it equal to ""

    // `word` still has the value `5` here, but `s` no longer has any content
    // that we could meaningfully use with the value `5`, so `word` is now
    // totally invalid!
}</code></pre></pre>
<figcaption>Listing 4-8: 存储调用 <code>first_word</code> 函数的结果，然后更改 <code>String</code> 内容</figcaption>
</figure>
<p>这个程序在没有任何错误的情况下编译，如果我们在调用 <code>s.clear()</code> 之后使用 <code>word</code>，它也会这样做。因为 <code>word</code> 与 <code>s</code> 的状态完全无关，<code>word</code> 仍然包含值 <code>5</code>。我们可以使用该值 <code>5</code> 与变量 <code>s</code> 尝试提取第一个单词，但这将是一个错误，因为自从我们在 <code>word</code> 中保存 <code>5</code> 以来，<code>s</code> 的内容已经发生了变化。</p>
<p>担心 <code>word</code> 中的索引与 <code>s</code> 中的数据不同步是繁琐且容易出错的！如果我们编写一个 <code>second_word</code> 函数，管理这些索引会更加脆弱。它的签名必须如下所示：</p>
<pre><code class="language-rust ignore">fn second_word(s: &amp;String) -&gt; (usize, usize) {</code></pre>
<p>现在我们正在跟踪一个起始索引和一个结束索引，我们有更多的值是从特定状态的数据计算出来的，但与那个状态完全没有关联。我们有三个不相关的变量需要保持同步。</p>
<p>幸运的是，Rust 有一个解决这个问题的方法：字符串切片。</p>
<h3 id="字符串切片"><a class="header" href="#字符串切片">字符串切片</a></h3>
<p><em>字符串切片</em> 是对 <code>String</code> 的一部分的引用，它看起来像这样：</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">fn main() {
</span>    let s = String::from("hello world");

    let hello = &amp;s[0..5];
    let world = &amp;s[6..11];
<span class="boring">}</span></code></pre></pre>
<p><code>hello</code> 不是对整个 <code>String</code> 的引用，而是对 <code>String</code> 的一部分的引用，由额外的 <code>[0..5]</code> 指定。我们通过在括号内指定 <code>[starting_index..ending_index]</code> 来创建切片，其中 <em><code>starting_index</code></em> 是切片的第一个位置，<em><code>ending_index</code></em> 是切片最后一个位置的下一个位置。在内部，切片数据结构存储了切片的起始位置和长度，长度对应于 <em><code>ending_index</code></em> 减去 <em><code>starting_index</code></em>。因此，在 <code>let world = &amp;s[6..11];</code> 的情况下，<code>world</code> 将是一个切片，它包含一个指向 <code>s</code> 索引 6 处的字节的指针，长度值为 <code>5</code>。</p>
<p>图 4-7 以图表形式展示了这一点。</p>
<p><img alt="三个表：一个表表示 s 的栈数据，它指向堆数据表中索引 0 处的字节，堆数据表包含字符串数据 &quot;hello world&quot;。第三个表表示切片 world 的栈数据，它的长度值为 5，并指向堆数据表的字节 6。"
src="img/trpl04-07.svg" class="center" style="width: 50%;" /></p>
<p><span class="caption">图 4-7: 字符串切片引用 <code>String</code> 的一部分</span></p>
<p>使用 Rust 的 <code>..</code> 范围语法，如果你想从索引 0 开始，可以省略两个点之前的值。换句话说，以下两种写法是等价的：</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let s = String::from("hello");

let slice = &amp;s[0..2];
let slice = &amp;s[..2];
<span class="boring">}</span></code></pre></pre>
<p>同样地，如果你的切片包括 <code>String</code> 的最后一个字节，你可以省略结尾的数字。这意味着以下两种写法是等价的：</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let s = String::from("hello");

let len = s.len();

let slice = &amp;s[3..len];
let slice = &amp;s[3..];
<span class="boring">}</span></code></pre></pre>
<p>你也可以省略两个值来获取整个字符串的切片。因此，以下两种写法是等价的：</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let s = String::from("hello");

let len = s.len();

let slice = &amp;s[0..len];
let slice = &amp;s[..];
<span class="boring">}</span></code></pre></pre>
<blockquote>
<p>注意：字符串切片的范围索引必须位于有效的 UTF-8 字符边界。如果你尝试在多字节字符的中间创建字符串切片，你的程序将会出错。为了介绍字符串切片，我们在本节中假设只使用 ASCII；关于 UTF-8 处理的更详细讨论在 <a href="ch08-02-strings.html#storing-utf-8-encoded-text-with-strings">第 8 章</a><!-- ignore --> 的“使用字符串存储 UTF-8 编码文本”部分。</p>
</blockquote>
<p>有了这些信息，让我们重写 <code>first_word</code> 以返回一个切片。表示“字符串切片”的类型写作 <code>&amp;str</code>：</p>
<figure class="listing">
<span class="file-name">Filename: src/main.rs</span>
<pre><pre class="playground"><code class="language-rust edition2024">fn first_word(s: &amp;String) -&gt; &amp;str {
    let bytes = s.as_bytes();

    for (i, &amp;item) in bytes.iter().enumerate() {
        if item == b' ' {
            return &amp;s[0..i];
        }
    }

    &amp;s[..]
}
<span class="boring">
</span><span class="boring">fn main() {}</span></code></pre></pre>
</figure>
<p>我们以与 Listing 4-7 相同的方式获取单词的结尾索引，即查找第一个空格的出现。当我们找到一个空格时，我们返回一个字符串切片，使用字符串的起始位置和空格的索引作为起始和结束索引。</p>
<p>现在当我们调用 <code>first_word</code> 时，我们得到一个与底层数据绑定的单一值。该值由切片的起始点的引用和切片中的元素数量组成。</p>
<p>返回切片也适用于 <code>second_word</code> 函数：</p>
<pre><code class="language-rust ignore">fn second_word(s: &amp;String) -&gt; &amp;str {</code></pre>
<p>我们现在有一个更不容易出错的直接 API，因为编译器将确保对 <code>String</code> 的引用保持有效。还记得 Listing 4-8 中的程序中的错误吗？当我们获取第一个单词的结尾索引，然后清空字符串，使我们的索引无效时？那段代码在逻辑上是错误的，但没有立即显示任何错误。如果我们继续尝试使用清空字符串的第一个单词索引，问题会在以后出现。切片使这个错误不可能发生，并让我们更早地知道代码有问题。使用切片版本的 <code>first_word</code> 会抛出一个编译时错误：</p>
<figure class="listing">
<span class="file-name">Filename: src/main.rs</span>
<pre><code class="language-rust ignore does_not_compile"><span class="boring">fn first_word(s: &amp;String) -&gt; &amp;str {
</span><span class="boring">    let bytes = s.as_bytes();
</span><span class="boring">
</span><span class="boring">    for (i, &amp;item) in bytes.iter().enumerate() {
</span><span class="boring">        if item == b' ' {
</span><span class="boring">            return &amp;s[0..i];
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    &amp;s[..]
</span><span class="boring">}
</span><span class="boring">
</span>fn main() {
    let mut s = String::from("hello world");

    let word = first_word(&amp;s);

    s.clear(); // error!

    println!("the first word is: {word}");
}</code></pre>
</figure>
<p>以下是编译器错误：</p>
<pre><code class="language-console">$ cargo run
   Compiling ownership v0.1.0 (file:///projects/ownership)
error[E0502]: cannot borrow `s` as mutable because it is also borrowed as immutable
  --&gt; src/main.rs:18:5
   |
16 |     let word = first_word(&amp;s);
   |                           -- immutable borrow occurs here
17 |
18 |     s.clear(); // error!
   |     ^^^^^^^^^ mutable borrow occurs here
19 |
20 |     println!("the first word is: {word}");
   |                                  ------ immutable borrow later used here

For more information about this error, try `rustc --explain E0502`.
error: could not compile `ownership` (bin "ownership") due to 1 previous error
</code></pre>
<p>回想一下借用规则，如果我们对某物有一个不可变引用，我们就不能同时获取一个可变引用。因为 <code>clear</code> 需要截断 <code>String</code>，它需要获取一个可变引用。<code>clear</code> 调用后的 <code>println!</code> 使用了 <code>word</code> 中的引用，因此不可变引用在此时必须仍然有效。Rust 不允许 <code>clear</code> 中的可变引用和 <code>word</code> 中的不可变引用同时存在，因此编译失败。Rust 不仅使我们的 API 更易于使用，而且还在编译时消除了整个类别的错误！</p>
<!-- 旧标题。不要删除或链接可能会中断。 -->
<p><a id="string-literals-are-slices"></a></p>
<h4 id="字符串字面量是切片"><a class="header" href="#字符串字面量是切片">字符串字面量是切片</a></h4>
<p>回想一下，我们讨论过字符串字面量存储在二进制文件中。现在我们知道切片，我们可以正确理解字符串字面量：</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let s = "Hello, world!";
<span class="boring">}</span></code></pre></pre>
<p>这里的 <code>s</code> 类型是 <code>&amp;str</code>：它是一个指向二进制文件中特定位置的切片。这也是为什么字符串字面量是不可变的；<code>&amp;str</code> 是一个不可变引用。</p>
<h4 id="字符串切片作为参数"><a class="header" href="#字符串切片作为参数">字符串切片作为参数</a></h4>
<p>知道你可以获取字面量和 <code>String</code> 值的切片，这让我们对 <code>first_word</code> 的签名有了进一步的改进：</p>
<pre><code class="language-rust ignore">fn first_word(s: &amp;String) -&gt; &amp;str {</code></pre>
<p>更有经验的 Rustacean 会编写 Listing 4-9 中所示的签名，因为它允许我们在 <code>&amp;String</code> 值和 <code>&amp;str</code> 值上使用相同的函数。</p>
<figure class="listing">
<pre><code class="language-rust ignore">fn first_word(s: &amp;str) -&gt; &amp;str {
<span class="boring">    let bytes = s.as_bytes();
</span><span class="boring">
</span><span class="boring">    for (i, &amp;item) in bytes.iter().enumerate() {
</span><span class="boring">        if item == b' ' {
</span><span class="boring">            return &amp;s[0..i];
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    &amp;s[..]
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    let my_string = String::from("hello world");
</span><span class="boring">
</span><span class="boring">    // `first_word` works on slices of `String`s, whether partial or whole.
</span><span class="boring">    let word = first_word(&amp;my_string[0..6]);
</span><span class="boring">    let word = first_word(&amp;my_string[..]);
</span><span class="boring">    // `first_word` also works on references to `String`s, which are equivalent
</span><span class="boring">    // to whole slices of `String`s.
</span><span class="boring">    let word = first_word(&amp;my_string);
</span><span class="boring">
</span><span class="boring">    let my_string_literal = "hello world";
</span><span class="boring">
</span><span class="boring">    // `first_word` works on slices of string literals, whether partial or
</span><span class="boring">    // whole.
</span><span class="boring">    let word = first_word(&amp;my_string_literal[0..6]);
</span><span class="boring">    let word = first_word(&amp;my_string_literal[..]);
</span><span class="boring">
</span><span class="boring">    // Because string literals *are* string slices already,
</span><span class="boring">    // this works too, without the slice syntax!
</span><span class="boring">    let word = first_word(my_string_literal);
</span><span class="boring">}</span></code></pre>
<figcaption>Listing 4-9: 通过使用字符串切片作为 <code>s</code> 参数的类型来改进 <code>first_word</code> 函数</figcaption>
</figure>
<p>如果我们有一个字符串切片，我们可以直接传递它。如果我们有一个 <code>String</code>，我们可以传递 <code>String</code> 的切片或对 <code>String</code> 的引用。这种灵活性利用了 <em>解引用强制转换</em>，我们将在 <a href="ch15-02-deref.html#implicit-deref-coercions-with-functions-and-methods">第 15 章</a><!--ignore--> 的“函数和方法的隐式解引用强制转换”部分讨论这一特性。</p>
<p>定义一个函数来接受字符串切片而不是对 <code>String</code> 的引用，使我们的 API 更通用且更有用，而不会失去任何功能：</p>
<figure class="listing">
<span class="file-name">Filename: src/main.rs</span>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">fn first_word(s: &amp;str) -&gt; &amp;str {
</span><span class="boring">    let bytes = s.as_bytes();
</span><span class="boring">
</span><span class="boring">    for (i, &amp;item) in bytes.iter().enumerate() {
</span><span class="boring">        if item == b' ' {
</span><span class="boring">            return &amp;s[0..i];
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    &amp;s[..]
</span><span class="boring">}
</span><span class="boring">
</span>fn main() {
    let my_string = String::from("hello world");

    // `first_word` works on slices of `String`s, whether partial or whole.
    let word = first_word(&amp;my_string[0..6]);
    let word = first_word(&amp;my_string[..]);
    // `first_word` also works on references to `String`s, which are equivalent
    // to whole slices of `String`s.
    let word = first_word(&amp;my_string);

    let my_string_literal = "hello world";

    // `first_word` works on slices of string literals, whether partial or
    // whole.
    let word = first_word(&amp;my_string_literal[0..6]);
    let word = first_word(&amp;my_string_literal[..]);

    // Because string literals *are* string slices already,
    // this works too, without the slice syntax!
    let word = first_word(my_string_literal);
}</code></pre></pre>
</figure>
<h3 id="其他切片"><a class="header" href="#其他切片">其他切片</a></h3>
<p>字符串切片，正如你可能想象的那样，是特定于字符串的。但也有一个更通用的切片类型。考虑这个数组：</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let a = [1, 2, 3, 4, 5];
<span class="boring">}</span></code></pre></pre>
<p>就像我们可能想引用字符串的一部分一样，我们可能想引用数组的一部分。我们可以这样做：</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let a = [1, 2, 3, 4, 5];

let slice = &amp;a[1..3];

assert_eq!(slice, &amp;[2, 3]);
<span class="boring">}</span></code></pre></pre>
<p>这个切片的类型是 <code>&amp;[i32]</code>。它的工作方式与字符串切片相同，通过存储对第一个元素的引用和长度。你会为各种其他集合使用这种切片。我们将在第 8 章讨论向量时详细讨论这些集合。</p>
<h2 id="总结"><a class="header" href="#总结">总结</a></h2>
<p>所有权、借用和切片的概念确保 Rust 程序在编译时的内存安全。Rust 语言让你像其他系统编程语言一样控制内存使用，但拥有数据的拥有者在超出作用域时自动清理数据，这意味着你不必编写和调试额外的代码来获得这种控制。</p>
<p>所有权影响 Rust 的许多其他部分的工作方式，因此我们将在本书的其余部分进一步讨论这些概念。让我们继续第 5 章，看看如何将数据分组到一个 <code>struct</code> 中。</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="ch04-02-references-and-borrowing.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="ch05-00-structs.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="ch04-02-references-and-borrowing.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="ch05-00-structs.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->
        <script src="ferris.js"></script>


    </div>
    </body>
</html>
