<!DOCTYPE HTML>
<html lang="en" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>使用 Async 实现并发 - Rust编程语言</title>


        <!-- Custom HTML head -->

        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" id="highlight-css" href="highlight.css">
        <link rel="stylesheet" id="tomorrow-night-css" href="tomorrow-night.css">
        <link rel="stylesheet" id="ayu-highlight-css" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="ferris.css">
        <link rel="stylesheet" href="theme/2018-edition.css">
        <link rel="stylesheet" href="theme/semantic-notes.css">
        <link rel="stylesheet" href="theme/listing.css">


        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="toc.js"></script>
    </head>
    <body>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var sidebar = null;
            var sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Rust编程语言</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/lxqddd/rust-book-cn" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h2 id="使用-async-实现并发"><a class="header" href="#使用-async-实现并发">使用 Async 实现并发</a></h2>
<!-- 旧标题。不要删除，否则链接可能会失效。 -->
<p><a id="concurrency-with-async"></a></p>
<p>在本节中，我们将把 async 应用到一些与第 16 章中使用线程解决的并发挑战相同的问题上。因为我们已经在那里讨论了很多关键概念，所以本节我们将重点放在线程和 futures 之间的区别上。</p>
<p>在许多情况下，使用 async 进行并发操作的 API 与使用线程的 API 非常相似。在其他情况下，它们最终会有很大的不同。即使线程和 async 的 API <strong>看起来</strong>相似，它们的行为通常也不同——而且它们的性能特征几乎总是不同。</p>
<!-- 旧标题。不要删除，否则链接可能会失效。 -->
<p><a id="counting"></a></p>
<h3 id="使用-spawn_task-创建新任务"><a class="header" href="#使用-spawn_task-创建新任务">使用 <code>spawn_task</code> 创建新任务</a></h3>
<p>在 <a href="ch16-01-threads.html#creating-a-new-thread-with-spawn">使用 Spawn 创建新线程</a><!-- ignore --> 中，我们解决的第一个操作是在两个独立的线程上进行计数。让我们使用 async 来做同样的事情。<code>trpl</code> crate 提供了一个 <code>spawn_task</code> 函数，看起来与 <code>thread::spawn</code> API 非常相似，以及一个 <code>sleep</code> 函数，它是 <code>thread::sleep</code> API 的 async 版本。我们可以一起使用这些函数来实现计数示例，如 Listing 17-6 所示。</p>
<figure class="listing">
<span class="file-name">Filename: src/main.rs</span>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">extern crate trpl; // required for mdbook test
</span><span class="boring">
</span>use std::time::Duration;

fn main() {
    trpl::run(async {
        trpl::spawn_task(async {
            for i in 1..10 {
                println!("hi number {i} from the first task!");
                trpl::sleep(Duration::from_millis(500)).await;
            }
        });

        for i in 1..5 {
            println!("hi number {i} from the second task!");
            trpl::sleep(Duration::from_millis(500)).await;
        }
    });
}</code></pre></pre>
<figcaption>Listing 17-6: 创建一个新任务来打印一些内容，同时主任务打印其他内容</figcaption>
</figure>
<p>作为我们的起点，我们使用 <code>trpl::run</code> 设置 <code>main</code> 函数，以便我们的顶层函数可以是 async 的。</p>
<blockquote>
<p>注意：从本章的这一点开始，每个示例都将包含与 <code>main</code> 中的 <code>trpl::run</code> 完全相同的包装代码，因此我们通常会像处理 <code>main</code> 一样跳过它。不要忘记在你的代码中包含它！</p>
</blockquote>
<p>然后我们在该块中编写两个循环，每个循环包含一个 <code>trpl::sleep</code> 调用，它在发送下一条消息之前等待半秒（500 毫秒）。我们将一个循环放在 <code>trpl::spawn_task</code> 的主体中，另一个放在顶层的 <code>for</code> 循环中。我们还在 <code>sleep</code> 调用之后添加了一个 <code>await</code>。</p>
<p>这段代码的行为与基于线程的实现类似——包括当你运行它时，可能会在终端中看到消息以不同的顺序出现：</p>
<!-- 不提取输出，因为输出的变化不显著；变化可能是由于线程运行方式不同，而不是编译器的变化 -->
<pre><code class="language-text">hi number 1 from the second task!
hi number 1 from the first task!
hi number 2 from the first task!
hi number 2 from the second task!
hi number 3 from the first task!
hi number 3 from the second task!
hi number 4 from the first task!
hi number 4 from the second task!
hi number 5 from the first task!
</code></pre>
<p>这个版本在主 async 块中的 <code>for</code> 循环完成后立即停止，因为由 <code>spawn_task</code> 生成的任务在 <code>main</code> 函数结束时被关闭。如果你希望它一直运行到任务完成，你需要使用一个 join 句柄来等待第一个任务完成。对于线程，我们使用 <code>join</code> 方法来“阻塞”直到线程运行完毕。在 Listing 17-7 中，我们可以使用 <code>await</code> 来做同样的事情，因为任务句柄本身就是一个 future。它的 <code>Output</code> 类型是一个 <code>Result</code>，所以我们在等待它之后还要解包它。</p>
<figure class="listing">
<span class="file-name">Filename: src/main.rs</span>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">extern crate trpl; // required for mdbook test
</span><span class="boring">
</span><span class="boring">use std::time::Duration;
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    trpl::run(async {
</span>        let handle = trpl::spawn_task(async {
            for i in 1..10 {
                println!("hi number {i} from the first task!");
                trpl::sleep(Duration::from_millis(500)).await;
            }
        });

        for i in 1..5 {
            println!("hi number {i} from the second task!");
            trpl::sleep(Duration::from_millis(500)).await;
        }

        handle.await.unwrap();
<span class="boring">    });
</span><span class="boring">}</span></code></pre></pre>
<figcaption>Listing 17-7: 使用 <code>await</code> 与 join 句柄一起运行任务直到完成</figcaption>
</figure>
<p>这个更新后的版本会一直运行，直到<strong>两个</strong>循环都完成。</p>
<!-- 不提取输出，因为输出的变化不显著；变化可能是由于线程运行方式不同，而不是编译器的变化 -->
<pre><code class="language-text">hi number 1 from the second task!
hi number 1 from the first task!
hi number 2 from the first task!
hi number 2 from the second task!
hi number 3 from the first task!
hi number 3 from the second task!
hi number 4 from the first task!
hi number 4 from the second task!
hi number 5 from the first task!
hi number 6 from the first task!
hi number 7 from the first task!
hi number 8 from the first task!
hi number 9 from the first task!
</code></pre>
<p>到目前为止，看起来 async 和线程给了我们相同的基本结果，只是语法不同：使用 <code>await</code> 而不是在 join 句柄上调用 <code>join</code>，并且等待 <code>sleep</code> 调用。</p>
<p>更大的区别是我们不需要生成另一个操作系统线程来执行此操作。事实上，我们甚至不需要在这里生成任务。因为 async 块编译为匿名的 futures，我们可以将每个循环放在一个 async 块中，并使用 <code>trpl::join</code> 函数让运行时将它们都运行到完成。</p>
<p>在 <a href="ch16-01-threads.html#waiting-for-all-threads-to-finish-using-join-handles">使用 <code>join</code> 句柄等待所有线程完成</a><!-- ignore --> 一节中，我们展示了如何在调用 <code>std::thread::spawn</code> 时返回的 <code>JoinHandle</code> 类型上使用 <code>join</code> 方法。<code>trpl::join</code> 函数类似，但用于 futures。当你给它两个 futures 时，它会生成一个新的 future，其输出是一个元组，包含你传入的每个 future 的输出，一旦它们<strong>都</strong>完成。因此，在 Listing 17-8 中，我们使用 <code>trpl::join</code> 来等待 <code>fut1</code> 和 <code>fut2</code> 完成。我们<strong>不</strong>等待 <code>fut1</code> 和 <code>fut2</code>，而是等待由 <code>trpl::join</code> 生成的新 future。我们忽略输出，因为它只是一个包含两个单元值的元组。</p>
<figure class="listing">
<span class="file-name">Filename: src/main.rs</span>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">extern crate trpl; // required for mdbook test
</span><span class="boring">
</span><span class="boring">use std::time::Duration;
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    trpl::run(async {
</span>        let fut1 = async {
            for i in 1..10 {
                println!("hi number {i} from the first task!");
                trpl::sleep(Duration::from_millis(500)).await;
            }
        };

        let fut2 = async {
            for i in 1..5 {
                println!("hi number {i} from the second task!");
                trpl::sleep(Duration::from_millis(500)).await;
            }
        };

        trpl::join(fut1, fut2).await;
<span class="boring">    });
</span><span class="boring">}</span></code></pre></pre>
<figcaption>Listing 17-8: 使用 <code>trpl::join</code> 等待两个匿名 futures</figcaption>
</figure>
<p>当我们运行这个时，我们看到两个 futures 都运行到完成：</p>
<!-- 不提取输出，因为输出的变化不显著；变化可能是由于线程运行方式不同，而不是编译器的变化 -->
<pre><code class="language-text">hi number 1 from the first task!
hi number 1 from the second task!
hi number 2 from the first task!
hi number 2 from the second task!
hi number 3 from the first task!
hi number 3 from the second task!
hi number 4 from the first task!
hi number 4 from the second task!
hi number 5 from the first task!
hi number 6 from the first task!
hi number 7 from the first task!
hi number 8 from the first task!
hi number 9 from the first task!
</code></pre>
<p>现在，你每次都会看到完全相同的顺序，这与我们在线程中看到的情况非常不同。这是因为 <code>trpl::join</code> 函数是<strong>公平的</strong>，意味着它平等地检查每个 future，交替进行，并且如果一个 future 准备好了，它不会让另一个 future 抢先。对于线程，操作系统决定检查哪个线程以及让它运行多长时间。对于 async Rust，运行时决定检查哪个任务。（实际上，细节会变得复杂，因为 async 运行时可能在底层使用操作系统线程作为其管理并发的一部分，因此保证公平性对运行时来说可能是更多的工作——但它仍然是可能的！）运行时不必保证任何给定操作的公平性，它们通常提供不同的 API 来让你选择是否需要公平性。</p>
<p>尝试一些这些变体来等待 futures，看看它们会做什么：</p>
<ul>
<li>移除一个或两个循环周围的 async 块。</li>
<li>在定义每个 async 块后立即等待它。</li>
<li>只将第一个循环包装在 async 块中，并在第二个循环的主体之后等待生成的 future。</li>
</ul>
<p>作为一个额外的挑战，看看你是否能在运行代码之前<strong>预测</strong>每种情况下的输出！</p>
<!-- 旧标题。不要删除，否则链接可能会失效。 -->
<p><a id="message-passing"></a></p>
<h3 id="使用消息传递在两个任务上进行计数"><a class="header" href="#使用消息传递在两个任务上进行计数">使用消息传递在两个任务上进行计数</a></h3>
<p>在 futures 之间共享数据也会很熟悉：我们将再次使用消息传递，但这次使用 async 版本的类型和函数。我们将采取与 <a href="ch16-02-message-passing.html">使用消息传递在线程之间传输数据</a><!-- ignore --> 中略有不同的路径，以说明基于线程和基于 futures 的并发之间的一些关键区别。在 Listing 17-9 中，我们将从一个单一的 async 块开始——<strong>不</strong>像我们生成一个单独的线程那样生成一个单独的任务。</p>
<figure class="listing">
<span class="file-name">Filename: src/main.rs</span>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">extern crate trpl; // required for mdbook test
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    trpl::run(async {
</span>        let (tx, mut rx) = trpl::channel();

        let val = String::from("hi");
        tx.send(val).unwrap();

        let received = rx.recv().await.unwrap();
        println!("Got: {received}");
<span class="boring">    });
</span><span class="boring">}</span></code></pre></pre>
<figcaption>Listing 17-9: 创建一个 async 通道并将两端分配给 <code>tx</code> 和 <code>rx</code></figcaption>
</figure>
<p>在这里，我们使用 <code>trpl::channel</code>，这是一个 async 版本的多生产者、单消费者通道 API，我们在第 16 章中与线程一起使用过。async 版本的 API 与基于线程的版本只有一点不同：它使用一个可变的而不是不可变的接收器 <code>rx</code>，并且它的 <code>recv</code> 方法生成一个我们需要等待的 future，而不是直接生成值。现在我们可以从发送者向接收者发送消息。注意，我们不需要生成一个单独的线程甚至任务；我们只需要等待 <code>rx.recv</code> 调用。</p>
<p><code>std::mpsc::channel</code> 中的同步 <code>Receiver::recv</code> 方法会阻塞，直到它收到消息。<code>trpl::Receiver::recv</code> 方法不会阻塞，因为它是 async 的。它不会阻塞，而是将控制权交还给运行时，直到收到消息或通道的发送端关闭。相比之下，我们不会等待 <code>send</code> 调用，因为它不会阻塞。它不需要阻塞，因为我们发送到的通道是无界的。</p>
<blockquote>
<p>注意：因为所有这些 async 代码都在 <code>trpl::run</code> 调用中的 async 块中运行，所以其中的所有内容都可以避免阻塞。然而，<strong>外部</strong>的代码会在 <code>run</code> 函数返回时阻塞。这就是 <code>trpl::run</code> 函数的全部意义：它让你<strong>选择</strong>在哪里阻塞某些 async 代码，从而在哪里在同步和异步代码之间进行转换。在大多数 async 运行时中，<code>run</code> 实际上被称为 <code>block_on</code>，正是因为这个原因。</p>
</blockquote>
<p>注意这个例子中的两件事。首先，消息会立即到达。其次，尽管我们在这里使用了一个 future，但还没有并发。列表中的所有内容都是按顺序发生的，就像没有 futures 参与一样。</p>
<p>让我们通过发送一系列消息并在它们之间休眠来解决第一部分，如 Listing 17-10 所示。</p>
<!-- 我们无法测试这个，因为它永远不会停止！ -->
<figure class="listing">
<span class="file-name">Filename: src/main.rs</span>
<pre><code class="language-rust ignore"><span class="boring">extern crate trpl; // required for mdbook test
</span><span class="boring">
</span><span class="boring">use std::time::Duration;
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    trpl::run(async {
</span>        let (tx, mut rx) = trpl::channel();

        let vals = vec![
            String::from("hi"),
            String::from("from"),
            String::from("the"),
            String::from("future"),
        ];

        for val in vals {
            tx.send(val).unwrap();
            trpl::sleep(Duration::from_millis(500)).await;
        }

        while let Some(value) = rx.recv().await {
            println!("received '{value}'");
        }
<span class="boring">    });
</span><span class="boring">}</span></code></pre>
<figcaption>Listing 17-10: 通过 async 通道发送和接收多条消息，并在每条消息之间使用 <code>await</code> 休眠</figcaption>
</figure>
<p>除了发送消息外，我们还需要接收它们。在这种情况下，因为我们知道有多少消息会进来，我们可以手动调用 <code>rx.recv().await</code> 四次。然而，在现实世界中，我们通常会等待一些<strong>未知</strong>数量的消息，所以我们需要一直等待，直到我们确定没有更多的消息。</p>
<p>在 Listing 16-10 中，我们使用了一个 <code>for</code> 循环来处理从同步通道接收的所有项目。Rust 还没有办法编写一个 <code>for</code> 循环来遍历一个<strong>异步</strong>系列的项目，所以我们需要使用一个我们之前没有见过的循环：<code>while let</code> 条件循环。这是我们在 <a href="ch06-03-if-let.html">使用 <code>if let</code> 和 <code>let else</code> 进行简洁控制流</a><!-- ignore --> 一节中看到的 <code>if let</code> 构造的循环版本。只要它指定的模式继续匹配值，循环就会继续执行。</p>
<p><code>rx.recv</code> 调用生成一个 future，我们等待它。运行时将暂停 future，直到它准备好。一旦消息到达，future 将解析为 <code>Some(message)</code>，每次消息到达时都会这样。当通道关闭时，无论<strong>是否</strong>有任何消息到达，future 将解析为 <code>None</code>，表示没有更多的值，因此我们应该停止轮询——即停止等待。</p>
<p><code>while let</code> 循环将所有这些结合在一起。如果调用 <code>rx.recv().await</code> 的结果是 <code>Some(message)</code>，我们可以访问消息并在循环体中使用它，就像我们可以使用 <code>if let</code> 一样。如果结果是 <code>None</code>，循环结束。每次循环完成时，它都会再次到达等待点，因此运行时再次暂停它，直到另一条消息到达。</p>
<p>代码现在成功地发送和接收了所有消息。不幸的是，仍然有几个问题。首先，消息不会以半秒的间隔到达。它们会在我们启动程序 2 秒（2000 毫秒）后一次性到达。其次，这个程序永远不会退出！相反，它会永远等待新消息。你需要使用 <span class="keystroke">ctrl-c</span> 来关闭它。</p>
<p>让我们首先检查为什么消息会在完整延迟后一次性到达，而不是在每条消息之间延迟。在给定的 async 块中，代码中 <code>await</code> 关键字出现的顺序也是程序运行时它们执行的顺序。</p>
<p>Listing 17-10 中只有一个 async 块，所以其中的所有内容都是线性运行的。仍然没有并发。所有的 <code>tx.send</code> 调用都会发生，穿插着所有的 <code>trpl::sleep</code> 调用及其相关的等待点。然后 <code>while let</code> 循环才会通过 <code>recv</code> 调用的任何等待点。</p>
<p>为了获得我们想要的行为，即每条消息之间的睡眠延迟，我们需要将 <code>tx</code> 和 <code>rx</code> 操作放在它们自己的 async 块中，如 Listing 17-11 所示。然后运行时可以使用 <code>trpl::join</code> 分别执行它们，就像在计数示例中一样。再次强调，我们等待调用 <code>trpl::join</code> 的结果，而不是单独的 futures。如果我们按顺序等待单独的 futures，我们最终会回到顺序流程——这正是我们<strong>不</strong>想做的事情。</p>
<!-- 我们无法测试这个，因为它永远不会停止！ -->
<figure class="listing">
<span class="file-name">Filename: src/main.rs</span>
<pre><code class="language-rust ignore"><span class="boring">extern crate trpl; // required for mdbook test
</span><span class="boring">
</span><span class="boring">use std::time::Duration;
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    trpl::run(async {
</span><span class="boring">        let (tx, mut rx) = trpl::channel();
</span><span class="boring">
</span>        let tx_fut = async {
            let vals = vec![
                String::from("hi"),
                String::from("from"),
                String::from("the"),
                String::from("future"),
            ];

            for val in vals {
                tx.send(val).unwrap();
                trpl::sleep(Duration::from_millis(500)).await;
            }
        };

        let rx_fut = async {
            while let Some(value) = rx.recv().await {
                println!("received '{value}'");
            }
        };

        trpl::join(tx_fut, rx_fut).await;
<span class="boring">    });
</span><span class="boring">}</span></code></pre>
<figcaption>Listing 17-11: 将 <code>send</code> 和 <code>recv</code> 分离到它们自己的 <code>async</code> 块中，并等待这些块的 futures</figcaption>
</figure>
<p>在 Listing 17-11 的更新代码中，消息以 500 毫秒的间隔打印，而不是在 2 秒后一次性到达。</p>
<p>然而，程序仍然不会退出，因为 <code>while let</code> 循环与 <code>trpl::join</code> 的交互方式：</p>
<ul>
<li>从 <code>trpl::join</code> 返回的 future 只有在传递给它的<strong>两个</strong> futures 都完成后才会完成。</li>
<li><code>tx</code> future 在发送完 <code>vals</code> 中的最后一条消息并完成休眠后完成。</li>
<li><code>rx</code> future 只有在 <code>while let</code> 循环结束后才会完成。</li>
<li><code>while let</code> 循环只有在等待 <code>rx.recv</code> 产生 <code>None</code> 时才会结束。</li>
<li>等待 <code>rx.recv</code> 只有在通道的另一端关闭时才会返回 <code>None</code>。</li>
<li>通道只有在调用 <code>rx.close</code> 或发送端 <code>tx</code> 被丢弃时才会关闭。</li>
<li>我们没有在任何地方调用 <code>rx.close</code>，并且 <code>tx</code> 只有在传递给 <code>trpl::run</code> 的最外层 async 块结束时才会被丢弃。</li>
<li>该块无法结束，因为它被阻塞在 <code>trpl::join</code> 完成上，这让我们回到了这个列表的顶部。</li>
</ul>
<p>我们可以通过调用 <code>rx.close</code> 来手动关闭 <code>rx</code>，但这没有多大意义。在处理一些任意数量的消息后停止会使程序关闭，但我们可能会错过消息。我们需要其他方法来确保 <code>tx</code> 在函数结束之前被丢弃。</p>
<p>现在，我们发送消息的 async 块只借用 <code>tx</code>，因为发送消息不需要所有权，但如果我们可以将 <code>tx</code> 移动到该 async 块中，它将在该块结束时被丢弃。在第 13 章的 <a href="ch13-01-closures.html#capturing-references-or-moving-ownership">捕获引用或移动所有权</a><!-- ignore --> 一节中，你学习了如何使用 <code>move</code> 关键字与闭包，并且如第 16 章的 <a href="ch16-01-threads.html#using-move-closures-with-threads">使用 <code>move</code> 闭包与线程</a><!-- ignore --> 一节中所讨论的，我们在使用线程时经常需要将数据移动到闭包中。同样的基本动态适用于 async 块，因此 <code>move</code> 关键字与 async 块一起使用，就像它与闭包一起使用一样。</p>
<p>在 Listing 17-12 中，我们将用于发送消息的块从 <code>async</code> 更改为 <code>async move</code>。当我们运行<strong>这个</strong>版本的代码时，它会在最后一条消息发送和接收后优雅地关闭。</p>
<figure class="listing">
<span class="file-name">Filename: src/main.rs</span>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">extern crate trpl; // required for mdbook test
</span><span class="boring">
</span><span class="boring">use std::time::Duration;
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    trpl::run(async {
</span>        let (tx, mut rx) = trpl::channel();

        let tx_fut = async move {
            let vals = vec![
                String::from("hi"),
                String::from("from"),
                String::from("the"),
                String::from("future"),
            ];

            for val in vals {
                tx.send(val).unwrap();
                trpl::sleep(Duration::from_millis(500)).await;
            }
        };

        let rx_fut = async {
            while let Some(value) = rx.recv().await {
                println!("received '{value}'");
            }
        };

        trpl::join(tx_fut, rx_fut).await;
<span class="boring">    });
</span><span class="boring">}</span></code></pre></pre>
<figcaption>Listing 17-12: Listing 17-11 代码的修订版，完成后正确关闭</figcaption>
</figure>
<p>这个 async 通道也是一个多生产者通道，所以如果我们想从多个 futures 发送消息，我们可以调用 <code>clone</code> 来复制 <code>tx</code>，如 Listing 17-13 所示。</p>
<figure class="listing">
<span class="file-name">Filename: src/main.rs</span>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">extern crate trpl; // required for mdbook test
</span><span class="boring">
</span><span class="boring">use std::time::Duration;
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    trpl::run(async {
</span>        let (tx, mut rx) = trpl::channel();

        let tx1 = tx.clone();
        let tx1_fut = async move {
            let vals = vec![
                String::from("hi"),
                String::from("from"),
                String::from("the"),
                String::from("future"),
            ];

            for val in vals {
                tx1.send(val).unwrap();
                trpl::sleep(Duration::from_millis(500)).await;
            }
        };

        let rx_fut = async {
            while let Some(value) = rx.recv().await {
                println!("received '{value}'");
            }
        };

        let tx_fut = async move {
            let vals = vec![
                String::from("more"),
                String::from("messages"),
                String::from("for"),
                String::from("you"),
            ];

            for val in vals {
                tx.send(val).unwrap();
                trpl::sleep(Duration::from_millis(1500)).await;
            }
        };

        trpl::join3(tx1_fut, tx_fut, rx_fut).await;
<span class="boring">    });
</span><span class="boring">}</span></code></pre></pre>
<figcaption>Listing 17-13: 使用 async 块的多生产者</figcaption>
</figure>
<p>首先，我们克隆 <code>tx</code>，在第一个 async 块之外创建 <code>tx1</code>。我们像之前对 <code>tx</code> 一样将 <code>tx1</code> 移动到该块中。然后，稍后，我们将原始的 <code>tx</code> 移动到一个<strong>新的</strong> async 块中，在那里我们以稍慢的延迟发送更多消息。我们碰巧将这个新的 async 块放在接收消息的 async 块之后，但它也可以放在前面。关键是 futures 被等待的顺序，而不是它们被创建的顺序。</p>
<p>发送消息的两个 async 块都需要是 <code>async move</code> 块，以便 <code>tx</code> 和 <code>tx1</code> 在这些块完成时被丢弃。否则，我们将回到我们开始的无限循环中。最后，我们从 <code>trpl::join</code> 切换到 <code>trpl::join3</code> 来处理额外的 future。</p>
<p>现在我们看到来自两个发送 futures 的所有消息，并且因为发送 futures 在发送后使用略有不同的延迟，消息也会以这些不同的间隔接收。</p>
<!-- 不提取输出，因为输出的变化不显著；变化可能是由于线程运行方式不同，而不是编译器的变化 -->
<pre><code class="language-text">received 'hi'
received 'more'
received 'from'
received 'the'
received 'messages'
received 'future'
received 'for'
received 'you'
</code></pre>
<p>这是一个好的开始，但它将我们限制在只有少数 futures：两个使用 <code>join</code>，或三个使用 <code>join3</code>。让我们看看我们如何可能处理更多的 futures。</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="ch17-01-futures-and-syntax.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="ch17-03-more-futures.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="ch17-01-futures-and-syntax.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="ch17-03-more-futures.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->
        <script src="ferris.js"></script>


    </div>
    </body>
</html>
