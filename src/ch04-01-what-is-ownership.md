## 什么是所有权？

_所有权_ 是一组规则，用于管理 Rust 程序如何管理内存。所有程序在运行时都需要管理它们使用计算机内存的方式。有些语言具有垃圾回收机制，在程序运行时定期查找不再使用的内存；而在其他语言中，程序员必须显式地分配和释放内存。Rust 采用了第三种方法：内存通过所有权系统进行管理，编译器会检查一组规则。如果违反了任何规则，程序将无法编译。所有权的特性不会在程序运行时减慢程序的速度。

由于所有权对许多程序员来说是一个新概念，确实需要一些时间来适应。好消息是，随着你对 Rust 和所有权系统规则的熟悉程度增加，你会发现自然而然地编写出安全且高效的代码。坚持下去！

当你理解了所有权，你就为理解 Rust 的独特特性打下了坚实的基础。在本章中，你将通过一些示例来学习所有权，这些示例专注于一个非常常见的数据结构：字符串。

> ### 栈和堆
>
> 许多编程语言并不要求你经常考虑栈和堆。但在像 Rust 这样的系统编程语言中，值是在栈上还是在堆上会影响语言的行为以及你为何需要做出某些决定。所有权的部分内容将在本章后面与栈和堆相关的内容中描述，因此这里先做一个简要的解释作为准备。
>
> 栈和堆都是代码在运行时可以使用的内存部分，但它们的结构不同。栈以获取值的顺序存储值，并以相反的顺序移除值。这被称为 _后进先出_。想象一下一叠盘子：当你添加更多盘子时，你把它们放在堆的顶部，当你需要一个盘子时，你从顶部取一个。从中间或底部添加或移除盘子效果不会那么好！添加数据被称为 _压入栈_，移除数据被称为 _弹出栈_。所有存储在栈上的数据必须具有已知的、固定的大小。在编译时大小未知或大小可能变化的数据必须存储在堆上。
>
> 堆的组织性较差：当你将数据放入堆时，你需要请求一定量的空间。内存分配器在堆中找到一个足够大的空位，将其标记为正在使用，并返回一个 _指针_，即该位置的地址。这个过程被称为 _在堆上分配_，有时简称为 _分配_（将值压入栈不被视为分配）。因为指向堆的指针是已知的、固定大小的，你可以将指针存储在栈上，但当你想要实际数据时，你必须跟随指针。想象一下在餐厅就座。当你进入时，你说明你们的人数，服务员会找到一个适合所有人的空桌子并带你过去。如果你们中有人迟到，他们可以询问你们坐在哪里来找到你。
>
> 将数据压入栈比在堆上分配要快，因为分配器永远不需要寻找存储新数据的地方；那个位置总是在栈的顶部。相比之下，在堆上分配空间需要更多的工作，因为分配器必须首先找到一个足够大的空间来容纳数据，然后进行簿记以准备下一次分配。
>
> 访问堆上的数据比访问栈上的数据要慢，因为你必须跟随指针才能到达那里。当代处理器在内存中跳转较少时速度更快。继续类比，想象一下餐厅的服务员从许多桌子接单。在移动到下一张桌子之前，先接完一张桌子的所有订单是最有效率的。从桌子 A 接一个订单，然后从桌子 B 接一个订单，然后再从桌子 A 接一个订单，再从桌子 B 接一个订单，这个过程会慢得多。同样，处理器在处理彼此靠近的数据（如在栈上）时比处理较远的数据（如在堆上）时能更好地完成工作。
>
> 当你的代码调用一个函数时，传递给函数的值（可能包括指向堆上数据的指针）和函数的局部变量会被压入栈。当函数结束时，这些值会从栈中弹出。
>
> 跟踪代码的哪些部分在使用堆上的哪些数据，最小化堆上重复数据的数量，以及清理堆上未使用的数据以避免空间耗尽，这些都是所有权要解决的问题。一旦你理解了所有权，你就不需要经常考虑栈和堆，但知道所有权的主要目的是管理堆数据可以帮助解释它为何以这种方式工作。

### 所有权规则

首先，让我们看一下所有权规则。在我们通过示例说明这些规则时，请牢记这些规则：

- Rust 中的每个值都有一个 _所有者_。
- 一次只能有一个所有者。
- 当所有者超出作用域时，值将被丢弃。

### 变量作用域

既然我们已经了解了基本的 Rust 语法，我们不会在示例中包含所有的 `fn main() {` 代码，所以如果你在跟随学习，请确保手动将以下示例放入 `main` 函数中。因此，我们的示例将更加简洁，让我们专注于实际细节而不是样板代码。

作为所有权的第一个示例，我们将查看一些变量的 _作用域_。作用域是程序中项目有效的范围。以以下变量为例：

```rust
let s = "hello";
```

变量 `s` 引用了一个字符串字面量，其中字符串的值被硬编码到我们的程序文本中。变量从声明点到当前 _作用域_ 结束都是有效的。Listing 4-1 展示了一个程序，其中注释标注了变量 `s` 的有效范围。

<Listing number="4-1" caption="一个变量及其有效的作用域">

```rust
{{#rustdoc_include ../listings/ch04-understanding-ownership/listing-04-01/src/main.rs:here}}
```

</Listing>

换句话说，这里有两个重要的时间点：

- 当 `s` _进入_ 作用域时，它是有效的。
- 它保持有效直到它 _超出_ 作用域。

此时，作用域和变量有效性的关系与其他编程语言中的类似。现在我们将在此基础上引入 `String` 类型。

### `String` 类型

为了说明所有权的规则，我们需要一个比我们在第 3 章的 [“数据类型”][data-types]<!-- ignore --> 部分中介绍的类型更复杂的数据类型。之前介绍的类型具有已知的大小，可以存储在栈上，并在其作用域结束时从栈中弹出，如果需要在不同作用域中使用相同的值，可以快速且轻松地复制以创建一个新的独立实例。但我们希望查看存储在堆上的数据，并探索 Rust 如何知道何时清理这些数据，而 `String` 类型就是一个很好的例子。

我们将专注于 `String` 与所有权相关的部分。这些方面也适用于其他复杂的数据类型，无论它们是由标准库提供的还是你自己创建的。我们将在 [第 8 章][ch8]<!-- ignore --> 中更深入地讨论 `String`。

我们已经见过字符串字面量，其中字符串值被硬编码到我们的程序中。字符串字面量很方便，但它们并不适合我们可能想要使用文本的每种情况。一个原因是它们是不可变的。另一个原因是我们编写代码时并非每个字符串值都是已知的：例如，如果我们想获取用户输入并存储它怎么办？对于这些情况，Rust 有第二种字符串类型，`String`。这种类型管理在堆上分配的数据，因此能够存储编译时未知大小的文本。你可以使用 `from` 函数从字符串字面量创建一个 `String`，如下所示：

```rust
let s = String::from("hello");
```

双冒号 `::` 运算符允许我们将这个特定的 `from` 函数命名空间放在 `String` 类型下，而不是使用类似 `string_from` 的名称。我们将在第 5 章的 [“方法语法”][method-syntax]<!-- ignore --> 部分以及在第 7 章的 [“模块树中引用项的路径”][paths-module-tree]<!-- ignore --> 中讨论模块命名空间时更详细地讨论这种语法。

这种字符串 _可以_ 被修改：

```rust
{{#rustdoc_include ../listings/ch04-understanding-ownership/no-listing-01-can-mutate-string/src/main.rs:here}}
```

那么，这里的区别是什么？为什么 `String` 可以被修改而字面量不能？区别在于这两种类型如何处理内存。

### 内存和分配

在字符串字面量的情况下，我们在编译时就知道内容，因此文本直接硬编码到最终的可执行文件中。这就是为什么字符串字面量快速且高效。但这些属性仅来自字符串字面量的不可变性。不幸的是，我们不能为每个在编译时大小未知且大小可能在程序运行时变化的文本片段在二进制文件中放入一块内存。

对于 `String` 类型，为了支持可变的、可增长的文本片段，我们需要在堆上分配一块编译时未知大小的内存来保存内容。这意味着：

- 必须在运行时从内存分配器请求内存。
- 当我们使用完 `String` 时，需要有一种方法将内存返回给分配器。

第一部分由我们完成：当我们调用 `String::from` 时，它的实现会请求所需的内存。这在编程语言中几乎是普遍的。

然而，第二部分是不同的。在具有 _垃圾回收器 (GC)_ 的语言中，GC 会跟踪并清理不再使用的内存，我们不需要考虑它。在大多数没有 GC 的语言中，我们有责任识别何时不再使用内存并调用代码显式释放它，就像我们请求它时一样。正确地做到这一点在历史上一直是一个困难的编程问题。如果我们忘记了，我们会浪费内存。如果我们过早地释放，我们会有一个无效的变量。如果我们释放两次，这也是一个错误。我们需要将一次 `allocate` 与一次 `free` 精确配对。

Rust 采取了不同的路径：一旦拥有内存的变量超出作用域，内存就会自动返回。以下是使用 `String` 而不是字符串字面量的 Listing 4-1 的作用域示例版本：

```rust
{{#rustdoc_include ../listings/ch04-understanding-ownership/no-listing-02-string-scope/src/main.rs:here}}
```

有一个自然的点可以让我们将 `String` 所需的内存返回给分配器：当 `s` 超出作用域时。当变量超出作用域时，Rust 会为我们调用一个特殊的函数。这个函数被称为 [`drop`][drop]<!-- ignore -->，它是 `String` 的作者可以放置代码以返回内存的地方。Rust 在右大括号处自动调用 `drop`。

> 注意：在 C++ 中，这种在项目生命周期结束时释放资源的模式有时被称为 _资源获取即初始化 (RAII)_。如果你使用过 RAII 模式，Rust 中的 `drop` 函数会让你感到熟悉。

这种模式对 Rust 代码的编写方式有深远的影响。现在看起来可能很简单，但在更复杂的情况下，当我们希望多个变量使用我们在堆上分配的数据时，代码的行为可能会出乎意料。让我们现在探索一些这些情况。

<!-- 旧标题。不要删除或链接可能会中断。 -->

<a id="ways-variables-and-data-interact-move"></a>

#### 变量与数据的交互：移动

在 Rust 中，多个变量可以以不同的方式与相同的数据交互。让我们看一个使用整数的示例，如 Listing 4-2 所示。

<Listing number="4-2" caption="将变量 `x` 的整数值赋给 `y`">

```rust
{{#rustdoc_include ../listings/ch04-understanding-ownership/listing-04-02/src/main.rs:here}}
```

</Listing>

我们可能猜到了这段代码的作用：“将值 `5` 绑定到 `x`；然后将 `x` 中的值复制并绑定到 `y`。” 我们现在有两个变量，`x` 和 `y`，它们都等于 `5`。这确实是正在发生的事情，因为整数是具有已知固定大小的简单值，这两个 `5` 值被压入栈。

现在让我们看看 `String` 版本：

```rust
{{#rustdoc_include ../listings/ch04-understanding-ownership/no-listing-03-string-move/src/main.rs:here}}
```

这看起来非常相似，所以我们可能会假设它的工作方式相同：即第二行会复制 `s1` 中的值并将其绑定到 `s2`。但这并不是完全发生的事情。

看一下图 4-1，了解 `String` 在底层发生了什么。`String` 由三部分组成，如左侧所示：指向保存字符串内容的内存的指针、长度和容量。这组数据存储在栈上。右侧是堆上保存内容的内存。

<img alt="两个表格：第一个表格包含 s1 在栈上的表示，包括其长度 (5)、容量 (5) 和指向第二个表格中第一个值的指针。第二个表格包含堆上字符串数据的表示，按字节排列。" src="img/trpl04-01.svg" class="center" style="width: 50%;" />

<span class="caption">图 4-1：绑定到 `s1` 的 `String` 值 `"hello"` 在内存中的表示</span>

长度是 `String` 内容当前使用的内存量（以字节为单位）。容量是 `String` 从分配器获得的总内存量（以字节为单位）。长度和容量之间的差异很重要，但在此上下文中并不重要，所以现在可以忽略容量。

当我们把 `s1` 赋值给 `s2` 时，`String` 数据被复制，这意味着我们复制了栈上的指针、长度和容量。我们没有复制指针所指向的堆上的数据。换句话说，内存中的数据表示如图 4-2 所示。

<img alt="三个表格：表格 s1 和 s2 分别表示这些字符串在栈上的表示，并且都指向堆上的相同字符串数据。" src="img/trpl04-02.svg" class="center" style="width: 50%;" />

<span class="caption">图 4-2：变量 `s2` 在内存中的表示，它复制了 `s1` 的指针、长度和容量</span>

表示 _不_ 像图 4-3 那样，如果 Rust 也复制堆数据，内存会是什么样子。如果 Rust 这样做，操作 `s2 = s1` 在运行时性能方面可能会非常昂贵，如果堆上的数据很大。

<img alt="四个表格：两个表格表示 s1 和 s2 的栈数据，每个都指向堆上自己的字符串数据副本。" src="img/trpl04-03.svg" class="center" style="width: 50%;" />

<span class="caption">图 4-3：如果 Rust 也复制堆数据，`s2 = s1` 可能做的另一种可能性</span>

早些时候，我们说过当变量超出作用域时，Rust 会自动调用 `drop` 函数并清理该变量的堆内存。但图 4-2 显示两个数据指针指向同一个位置。这是一个问题：当 `s2` 和 `s1` 超出作用域时，它们都会尝试释放相同的内存。这被称为 _双重释放_ 错误，是我们之前提到的内存安全错误之一。释放内存两次可能导致内存损坏，从而可能引发安全漏洞。

为了确保内存安全，在 `let s2 = s1;` 行之后，Rust 认为 `s1` 不再有效。因此，当 `s1` 超出作用域时，Rust 不需要释放任何东西。看看当你尝试在 `s2` 创建后使用 `s1` 时会发生什么；它不会工作：

```rust,ignore,does_not_compile
{{#rustdoc_include ../listings/ch04-understanding-ownership/no-listing-04-cant-use-after-move/src/main.rs:here}}
```

你会得到一个类似这样的错误，因为 Rust 阻止你使用无效的引用：

```console
{{#include ../listings/ch04-understanding-ownership/no-listing-04-cant-use-after-move/output.txt}}
```

如果你在其他语言中听说过 _浅拷贝_ 和 _深拷贝_ 这两个术语，复制指针、长度和容量而不复制数据的概念可能听起来像是在进行浅拷贝。但由于 Rust 也使第一个变量无效，因此它被称为 _移动_ 而不是浅拷贝。在这个例子中，我们会说 `s1` 被 _移动_ 到了 `s2` 中。所以，实际发生的情况如图 4-4 所示。

<img alt="三个表格：表格 s1 和 s2 分别表示这些字符串在栈上的表示，并且都指向堆上的相同字符串数据。表格 s1 被灰显，因为 s1 不再有效；只有 s2 可以用来访问堆数据。" src="img/trpl04-04.svg" class="center" style="width: 50%;" />

<span class="caption">图 4-4：`s1` 无效化后的内存表示</span>

这解决了我们的问题！只有 `s2` 有效，当它超出作用域时，它将独自释放内存，我们就完成了。

此外，这还隐含了一个设计选择：Rust 永远不会自动创建数据的“深”拷贝。因此，任何 _自动_ 复制都可以假定在运行时性能方面是廉价的。

#### 作用域与赋值

对于作用域、所有权和通过 `drop` 函数释放内存之间的关系，反之亦然。当你将一个全新的值赋给现有变量时，Rust 会立即调用 `drop` 并释放原始值的内存。例如，考虑以下代码：

```rust
{{#rustdoc_include ../listings/ch04-understanding-ownership/no-listing-04b-replacement-drop/src/main.rs:here}}
```

我们最初声明了一个变量 `s` 并将其绑定到一个值为 `"hello"` 的 `String`。然后我们立即创建一个值为 `"ahoy"` 的新 `String` 并将其赋给 `s`。此时，没有任何东西引用堆上的原始值。

<img alt="一个表格 s 表示栈上的字符串值，指向堆上的第二块字符串数据 (ahoy)，原始字符串数据 (hello) 被灰显，因为它无法再被访问。" src="img/trpl04-05.svg" class="center" style="width: 50%;" />

<span class="caption">图 4-5：初始值被完全替换后的内存表示</span>

因此，原始字符串立即超出作用域。Rust 将对其运行 `drop` 函数，其内存将立即被释放。当我们打印末尾的值时，它将是 `"ahoy, world!"`。

<!-- 旧标题。不要删除或链接可能会中断。 -->

<a id="ways-variables-and-data-interact-clone"></a>

#### 变量与数据的交互：克隆

如果我们 _确实_ 想要深度复制 `String` 的堆数据，而不仅仅是栈数据，我们可以使用一个常见的方法叫做 `clone`。我们将在第 5 章讨论方法语法，但由于方法是许多编程语言中的常见特性，你可能已经见过它们。

以下是 `clone` 方法的示例：

```rust
{{#rustdoc_include ../listings/ch04-understanding-ownership/no-listing-05-clone/src/main.rs:here}}
```

这工作得很好，并明确产生了图 4-3 中所示的行为，其中堆数据 _确实_ 被复制了。

当你看到 `clone` 调用时，你知道正在执行一些任意代码，并且该代码可能很昂贵。这是一个视觉指示器，表明正在发生一些不同的事情。

#### 仅栈数据：复制

我们还没有讨论的另一个问题是。这段使用整数的代码——部分内容如 Listing 4-2 所示——是有效的：

```rust
{{#rustdoc_include ../listings/ch04-understanding-ownership/no-listing-06-copy/src/main.rs:here}}
```

但这段代码似乎与我们刚刚学到的内容相矛盾：我们没有调用 `clone`，但 `x` 仍然有效，并且没有被移动到 `y`。

原因是像整数这样在编译时已知大小的类型完全存储在栈上，因此复制实际值很快。这意味着我们没有理由在创建变量 `y` 后阻止 `x` 保持有效。换句话说，这里没有深度和浅度复制的区别，因此调用 `clone` 不会与通常的浅度复制有任何不同，我们可以省略它。

Rust 有一个特殊的注解叫做 `Copy` 特性，我们可以将其放在存储在栈上的类型上，就像整数一样（我们将在 [第 10 章][traits]<!-- ignore --> 中更详细地讨论特性）。如果一个类型实现了 `Copy` 特性，使用它的变量不会移动，而是被简单地复制，使它们在赋值给另一个变量后仍然有效。

如果类型或其任何部分实现了 `Drop` 特性，Rust 不会让我们用 `Copy` 注解该类型。如果类型需要在值超出作用域时发生一些特殊的事情，而我们为该类型添加了 `Copy` 注解，我们将得到一个编译时错误。要了解如何将 `Copy` 注解添加到你的类型以实现该特性，请参阅附录 C 中的 [“可派生特性”][derivable-traits]<!-- ignore -->。

那么，哪些类型实现了 `Copy` 特性？你可以查看给定类型的文档以确定，但作为一般规则，任何简单的标量值组都可以实现 `Copy`，而任何需要分配或某种形式的资源的东西都不能实现 `Copy`。以下是一些实现 `Copy` 的类型：

- 所有整数类型，如 `u32`。
- 布尔类型 `bool`，值为 `true` 和 `false`。
- 所有浮点类型，如 `f64`。
- 字符类型 `char`。
- 元组，如果它们只包含也实现 `Copy` 的类型。例如，`(i32, i32)` 实现了 `Copy`，但 `(i32, String)` 没有。

### 所有权与函数

将值传递给函数的机制与将值赋给变量的机制类似。将变量传递给函数会移动或复制，就像赋值一样。Listing 4-3 有一个带有注释的示例，显示了变量进入和退出作用域的位置。

<Listing number="4-3" file-name="src/main.rs" caption="带有所有权和作用域注释的函数">

```rust
{{#rustdoc_include ../listings/ch04-understanding-ownership/listing-04-03/src/main.rs}}
```

</Listing>

如果我们尝试在调用 `takes_ownership` 后使用 `s`，Rust 会抛出一个编译时错误。这些静态检查保护我们免于犯错。尝试在 `main` 中添加使用 `s` 和 `x` 的代码，看看你可以在哪里使用它们，以及所有权规则在哪里阻止你这样做。

### 返回值与作用域

返回值也可以转移所有权。Listing 4-4 展示了一个返回某些值的函数示例，其注释与 Listing 4-3 中的类似。

<Listing number="4-4" file-name="src/main.rs" caption="返回值的所有权转移">

```rust
{{#rustdoc_include ../listings/ch04-understanding-ownership/listing-04-04/src/main.rs}}
```

</Listing>

变量的所有权每次遵循相同的模式：将值赋给另一个变量会移动它。当包含堆上数据的变量超出作用域时，除非数据的所有权已转移到另一个变量，否则该值将被 `drop` 清理。

虽然这有效，但每次函数都获取所有权然后返回所有权有点繁琐。如果我们想让函数使用一个值但不获取所有权怎么办？我们传递的任何东西也需要传递回来，如果我们想再次使用它，这很烦人，此外我们可能还想返回函数体产生的任何数据。

Rust 确实允许我们使用元组返回多个值，如 Listing 4-5 所示。

<Listing number="4-5" file-name="src/main.rs" caption="返回参数的所有权">

```rust
{{#rustdoc_include ../listings/ch04-understanding-ownership/listing-04-05/src/main.rs}}
```

</Listing>

但对于一个应该很常见的概念来说，这太繁琐了，工作量也很大。幸运的是，Rust 有一个特性可以在不转移所有权的情况下使用值，称为 _引用_。

[data-types]: ch03-02-data-types.html#data-types
[ch8]: ch08-02-strings.html
[traits]: ch10-02-traits.html
[derivable-traits]: appendix-03-derivable-traits.html
[method-syntax]: ch05-03-method-syntax.html#method-syntax
[paths-module-tree]: ch07-03-paths-for-referring-to-an-item-in-the-module-tree.html
[drop]: ../std/ops/trait.Drop.html#tymethod.drop