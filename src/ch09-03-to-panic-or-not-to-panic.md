## 使用 `panic!` 还是不使用 `panic!`

那么，你该如何决定何时应该调用 `panic!`，何时应该返回 `Result` 呢？当代码 panic 时，是没有恢复的办法的。你可以在任何错误情况下调用 `panic!`，无论是否有恢复的可能，但这样你就代替调用代码做出了这个情况是不可恢复的决定。当你选择返回 `Result` 值时，你给了调用代码选择的机会。调用代码可以选择尝试以适合其情况的方式恢复，或者它可以决定在这种情况下 `Err` 值是不可恢复的，因此它可以调用 `panic!` 并将你的可恢复错误转换为不可恢复的错误。因此，返回 `Result` 是定义可能失败的函数时的默认选择。

在示例、原型代码和测试等情况下，编写 panic 的代码比返回 `Result` 更合适。让我们探讨一下原因，然后讨论编译器无法判断失败是不可能的，但你作为人类可以判断的情况。本章将以一些关于如何在库代码中决定是否 panic 的通用指南作为总结。

### 示例、原型代码和测试

当你编写示例来说明某个概念时，包含健壮的错误处理代码可能会使示例变得不那么清晰。在示例中，调用像 `unwrap` 这样可能会 panic 的方法是为了作为你想要应用程序处理错误的方式的占位符，这可能会根据代码的其他部分而有所不同。

同样，`unwrap` 和 `expect` 方法在原型设计时非常方便，在你准备好决定如何处理错误之前。它们在你的代码中留下了清晰的标记，以便在你准备好使程序更健壮时使用。

如果测试中的方法调用失败，你会希望整个测试失败，即使该方法不是正在测试的功能。因为 `panic!` 是测试标记为失败的方式，调用 `unwrap` 或 `expect` 正是应该发生的事情。

### 当你比编译器拥有更多信息时

当你有一些其他逻辑确保 `Result` 将有一个 `Ok` 值时，调用 `unwrap` 或 `expect` 也是合适的，但编译器不理解这种逻辑。你仍然需要处理一个 `Result` 值：无论你调用的操作在一般情况下都有可能失败，即使在你特定的情况下逻辑上是不可能的。如果你可以通过手动检查代码确保永远不会有一个 `Err` 变体，那么调用 `unwrap` 是完全可接受的，甚至在 `expect` 文本中记录你认为永远不会有一个 `Err` 变体的原因会更好。这里有一个例子：

```rust
{{#rustdoc_include ../listings/ch09-error-handling/no-listing-08-unwrap-that-cant-fail/src/main.rs:here}}
```

我们通过解析一个硬编码的字符串来创建一个 `IpAddr` 实例。我们可以看到 `127.0.0.1` 是一个有效的 IP 地址，所以在这里使用 `expect` 是可以接受的。然而，拥有一个硬编码的有效字符串并不会改变 `parse` 方法的返回类型：我们仍然会得到一个 `Result` 值，编译器仍然会让我们处理 `Result`，就好像 `Err` 变体是有可能的一样，因为编译器不够聪明，无法看到这个字符串始终是一个有效的 IP 地址。如果 IP 地址字符串来自用户而不是硬编码到程序中，因此确实有可能失败，我们肯定会希望以更健壮的方式处理 `Result`。提到这个 IP 地址是硬编码的假设会提示我们，如果将来需要从其他来源获取 IP 地址，我们需要将 `expect` 改为更好的错误处理代码。

### 错误处理指南

当你的代码可能进入不良状态时，建议让你的代码 panic。在这种情况下，**不良状态** 是指某些假设、保证、契约或不变量被破坏，例如当无效值、矛盾值或缺失值传递给你的代码时——再加上以下一个或多个条件：

- 不良状态是意外的，而不是偶尔可能发生的事情，比如用户输入了错误格式的数据。
- 此后的代码需要依赖不处于这种不良状态，而不是在每一步都检查问题。
- 在你使用的类型中没有好的方法来编码这些信息。我们将在第 18 章的 [“将状态和行为编码为类型”][encoding] 中通过一个例子来说明我们的意思。

如果有人调用你的代码并传入没有意义的值，最好返回一个错误，以便库的用户可以决定在这种情况下他们想要做什么。然而，在继续下去可能不安全或有害的情况下，最好的选择可能是调用 `panic!` 并提醒使用你的库的人他们的代码中有 bug，以便他们在开发过程中修复它。同样，如果你调用的外部代码不在你的控制范围内，并且它返回了一个你无法修复的无效状态，`panic!` 通常是合适的。

然而，当失败是预期的时候，返回 `Result` 比调用 `panic!` 更合适。例如，解析器接收到格式错误的数据或 HTTP 请求返回一个表明你已经达到速率限制的状态。在这些情况下，返回 `Result` 表明失败是一个预期的可能性，调用代码必须决定如何处理。

当你的代码执行一个操作，如果使用无效值调用可能会使用户处于风险之中时，你的代码应该首先验证这些值是否有效，如果值无效则 panic。这主要是出于安全原因：尝试对无效数据进行操作可能会使你的代码暴露于漏洞中。这是标准库在你尝试越界内存访问时会调用 `panic!` 的主要原因：尝试访问不属于当前数据结构的内存是一个常见的安全问题。函数通常有**契约**：只有在输入满足特定要求时，它们的行为才能得到保证。当契约被违反时 panic 是有意义的，因为契约违反总是表明调用方的 bug，这不是你希望调用代码必须显式处理的一种错误。事实上，调用代码没有合理的方式来恢复；调用**程序员**需要修复代码。函数的契约，尤其是当违反会导致 panic 时，应该在函数的 API 文档中解释。

然而，在所有函数中进行大量错误检查会显得冗长且烦人。幸运的是，你可以使用 Rust 的类型系统（以及编译器进行的类型检查）来为你完成许多检查。如果你的函数有一个特定类型作为参数，你可以继续进行代码逻辑，知道编译器已经确保你有一个有效的值。例如，如果你有一个类型而不是 `Option`，你的程序期望有**某些东西**而不是**什么都没有**。然后你的代码不必处理 `Some` 和 `None` 变体的两种情况：它只会有一个肯定有值的情况。尝试将空值传递给你的函数的代码甚至不会编译，因此你的函数不必在运行时检查这种情况。另一个例子是使用无符号整数类型，如 `u32`，它确保参数永远不会是负数。

### 创建自定义类型进行验证

让我们进一步利用 Rust 的类型系统来确保我们有一个有效的值，并看看如何创建一个用于验证的自定义类型。回想一下第 2 章中的猜数字游戏，我们的代码要求用户猜一个 1 到 100 之间的数字。我们在检查用户的猜测与我们的秘密数字之前从未验证过用户的猜测是否在这些数字之间；我们只验证了猜测是正数。在这种情况下，后果并不严重：我们的“太高”或“太低”的输出仍然是正确的。但引导用户进行有效的猜测并在用户猜测超出范围的数字时与用户输入字母时具有不同的行为将是一个有用的增强。

一种方法是解析猜测为 `i32` 而不是仅解析为 `u32` 以允许潜在的负数，然后添加一个检查以确保数字在范围内，如下所示：

<Listing file-name="src/main.rs">

```rust,ignore
{{#rustdoc_include ../listings/ch09-error-handling/no-listing-09-guess-out-of-range/src/main.rs:here}}
```

</Listing>

`if` 表达式检查我们的值是否超出范围，告诉用户问题，并调用 `continue` 开始循环的下一次迭代并要求另一个猜测。在 `if` 表达式之后，我们可以继续进行 `guess` 和秘密数字之间的比较，知道 `guess` 在 1 到 100 之间。

然而，这并不是一个理想的解决方案：如果绝对关键的是程序只在 1 到 100 之间的值上操作，并且它有许多函数有这个要求，那么在每个函数中进行这样的检查将是繁琐的（并且可能会影响性能）。

相反，我们可以创建一个新类型，并将验证放在一个函数中以创建该类型的实例，而不是到处重复验证。这样，函数在它们的签名中使用新类型是安全的，并且可以自信地使用它们接收到的值。清单 9-13 展示了一种定义 `Guess` 类型的方法，只有在 `new` 函数接收到 1 到 100 之间的值时才会创建 `Guess` 的实例。

<Listing number="9-13" caption="一个 `Guess` 类型，只有在值在 1 到 100 之间时才会继续">

```rust
{{#rustdoc_include ../listings/ch09-error-handling/listing-09-13/src/lib.rs}}
```

</Listing>

首先我们定义一个名为 `Guess` 的结构体，它有一个名为 `value` 的字段，该字段保存一个 `i32`。这是数字将存储的地方。

然后我们在 `Guess` 上实现一个名为 `new` 的关联函数，该函数创建 `Guess` 值的实例。`new` 函数被定义为一个名为 `value` 的 `i32` 类型的参数，并返回一个 `Guess`。`new` 函数体中的代码测试 `value` 以确保它在 1 到 100 之间。如果 `value` 没有通过这个测试，我们调用 `panic!`，这将提醒编写调用代码的程序员他们有一个需要修复的 bug，因为创建一个 `value` 超出这个范围的 `Guess` 将违反 `Guess::new` 所依赖的契约。`Guess::new` 可能 panic 的条件应该在其公开的 API 文档中讨论；我们将在第 14 章中介绍在 API 文档中指示 `panic!` 可能性的文档约定。如果 `value` 通过了测试，我们创建一个新的 `Guess`，其 `value` 字段设置为 `value` 参数，并返回 `Guess`。

接下来，我们实现一个名为 `value` 的方法，该方法借用 `self`，没有其他参数，并返回一个 `i32`。这种类型的方法有时被称为**getter**，因为它的目的是从其字段中获取一些数据并返回它。这个公共方法是必要的，因为 `Guess` 结构体的 `value` 字段是私有的。`value` 字段是私有的很重要，这样使用 `Guess` 结构体的代码不允许直接设置 `value`：模块外的代码**必须**使用 `Guess::new` 函数来创建 `Guess` 的实例，从而确保没有一种方式可以让 `Guess` 拥有一个未通过 `Guess::new` 函数中的条件检查的 `value`。

一个函数如果有一个参数或只返回 1 到 100 之间的数字，那么它可以在其签名中声明它接受或返回一个 `Guess` 而不是 `i32`，并且不需要在其主体中进行任何额外的检查。

## 总结

Rust 的错误处理功能旨在帮助你编写更健壮的代码。`panic!` 宏表示你的程序处于无法处理的状态，并让你告诉进程停止，而不是尝试继续使用无效或不正确的值。`Result` 枚举使用 Rust 的类型系统来指示操作可能会以你的代码可以恢复的方式失败。你可以使用 `Result` 来告诉调用你的代码的代码它需要处理潜在的成功或失败。在适当的情况下使用 `panic!` 和 `Result` 将使你的代码在面对不可避免的问题时更加可靠。

现在你已经看到了标准库如何使用泛型与 `Option` 和 `Result` 枚举的有用方式，我们将讨论泛型的工作原理以及如何在你的代码中使用它们。

[encoding]: ch18-03-oo-design-patterns.html#encoding-states-and-behavior-as-types