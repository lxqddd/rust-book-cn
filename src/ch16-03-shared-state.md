## 共享状态的并发

消息传递是处理并发的一种好方法，但它并不是唯一的方法。另一种方法是让多个线程访问相同的共享数据。再次考虑 Go 语言文档中的口号部分：“不要通过共享内存来通信。”

通过共享内存进行通信会是什么样子？此外，为什么消息传递的爱好者会警告不要使用内存共享？

在某种程度上，任何编程语言中的通道都类似于单一所有权，因为一旦你将一个值传递到通道中，你就不应该再使用该值。共享内存的并发类似于多重所有权：多个线程可以同时访问相同的内存位置。正如你在第 15 章中看到的，智能指针使得多重所有权成为可能，多重所有权会增加复杂性，因为这些不同的所有者需要管理。Rust 的类型系统和所有权规则极大地帮助了正确管理这些所有者。举个例子，让我们看看互斥锁（Mutex），它是共享内存中更常见的并发原语之一。

### 使用互斥锁允许一次只有一个线程访问数据

**Mutex** 是 **mutual exclusion**（互斥）的缩写，意思是互斥锁在任何给定时间只允许一个线程访问某些数据。要访问互斥锁中的数据，线程必须首先通过请求获取互斥锁的**锁**来发出信号。锁是互斥锁的一部分数据结构，用于跟踪当前谁拥有对数据的独占访问权限。因此，互斥锁被描述为通过锁定系统**保护**它所持有的数据。

互斥锁以难以使用而闻名，因为你必须记住两条规则：

1. 在使用数据之前，你必须尝试获取锁。
2. 当你使用完互斥锁保护的数据后，你必须解锁数据，以便其他线程可以获取锁。

对于互斥锁的现实比喻，想象一下会议上的小组讨论，只有一个麦克风。在小组成员发言之前，他们必须请求或发出信号表示他们想要使用麦克风。当他们拿到麦克风后，他们可以随心所欲地发言，然后将麦克风交给下一个请求发言的小组成员。如果一个小组成员在发言结束后忘记交出麦克风，其他人就无法发言。如果共享麦克风的管理出现问题，小组讨论将无法按计划进行！

互斥锁的管理可能非常棘手，这就是为什么很多人对通道如此热衷。然而，得益于 Rust 的类型系统和所有权规则，你不会在锁定和解锁上出错。

#### `Mutex<T>` 的 API

作为如何使用互斥锁的示例，让我们首先在单线程上下文中使用互斥锁，如 Listing 16-12 所示。

<Listing number="16-12" file-name="src/main.rs" caption="在单线程上下文中探索 `Mutex<T>` 的 API，以便简化">

```rust
{{#rustdoc_include ../listings/ch16-fearless-concurrency/listing-16-12/src/main.rs}}
```

</Listing>

与许多类型一样，我们使用关联函数 `new` 创建一个 `Mutex<T>`。要访问互斥锁中的数据，我们使用 `lock` 方法获取锁。这个调用会阻塞当前线程，直到轮到我们获取锁为止。

如果另一个持有锁的线程 panic 了，`lock` 调用将失败。在这种情况下，没有人能够获取锁，因此我们选择 `unwrap`，并让这个线程在这种情况下 panic。

在我们获取锁之后，我们可以将返回值（在本例中命名为 `num`）视为对内部数据的可变引用。类型系统确保我们在使用 `m` 中的值之前获取锁。`m` 的类型是 `Mutex<i32>`，而不是 `i32`，因此我们**必须**调用 `lock` 才能使用 `i32` 值。我们不能忘记；类型系统不会让我们以其他方式访问内部的 `i32`。

正如你可能怀疑的那样，`Mutex<T>` 是一个智能指针。更准确地说，`lock` 调用**返回**一个名为 `MutexGuard` 的智能指针，它被包装在一个 `LockResult` 中，我们通过调用 `unwrap` 来处理它。`MutexGuard` 智能指针实现了 `Deref` 以指向我们的内部数据；智能指针还有一个 `Drop` 实现，当 `MutexGuard` 超出作用域时，它会自动释放锁，这发生在内部作用域结束时。因此，我们不会冒险忘记释放锁并阻止其他线程使用互斥锁，因为锁的释放是自动发生的。

在释放锁之后，我们可以打印互斥锁的值，并看到我们能够将内部的 `i32` 更改为 6。

#### 在多个线程之间共享 `Mutex<T>`

现在让我们尝试使用 `Mutex<T>` 在多个线程之间共享一个值。我们将启动 10 个线程，并让每个线程将计数器值增加 1，因此计数器从 0 变为 10。Listing 16-13 中的示例将出现编译器错误，我们将使用该错误来了解更多关于使用 `Mutex<T>` 的知识，以及 Rust 如何帮助我们正确使用它。

<Listing number="16-13" file-name="src/main.rs" caption="十个线程，每个线程递增一个由 `Mutex<T>` 保护的计数器">

```rust,ignore,does_not_compile
{{#rustdoc_include ../listings/ch16-fearless-concurrency/listing-16-13/src/main.rs}}
```

</Listing>

我们创建一个 `counter` 变量来保存 `Mutex<T>` 中的 `i32`，就像我们在 Listing 16-12 中所做的那样。接下来，我们通过迭代一个数字范围来创建 10 个线程。我们使用 `thread::spawn` 并给所有线程相同的闭包：一个将 `counter` 移动到线程中，通过调用 `lock` 方法获取 `Mutex<T>` 的锁，然后将互斥锁中的值增加 1。当一个线程运行完它的闭包后，`num` 将超出作用域并释放锁，以便另一个线程可以获取它。

在主线程中，我们收集所有的 join 句柄。然后，就像我们在 Listing 16-2 中所做的那样，我们对每个句柄调用 `join` 以确保所有线程都完成。此时，主线程将获取锁并打印此程序的结果。

我们暗示这个示例不会编译。现在让我们找出原因！

```console
{{#include ../listings/ch16-fearless-concurrency/listing-16-13/output.txt}}
```

错误消息指出，`counter` 值在上一次循环迭代中被移动了。Rust 告诉我们，我们不能将锁 `counter` 的所有权移动到多个线程中。让我们使用第 15 章中讨论的多重所有权方法来修复编译器错误。

#### 多线程中的多重所有权

在第 15 章中，我们通过使用智能指针 `Rc<T>` 创建一个引用计数值来将值赋予多个所有者。让我们在这里做同样的事情，看看会发生什么。我们将在 Listing 16-14 中将 `Mutex<T>` 包装在 `Rc<T>` 中，并在将所有权移动到线程之前克隆 `Rc<T>`。

<Listing number="16-14" file-name="src/main.rs" caption="尝试使用 `Rc<T>` 允许多个线程拥有 `Mutex<T>`">

```rust,ignore,does_not_compile
{{#rustdoc_include ../listings/ch16-fearless-concurrency/listing-16-14/src/main.rs}}
```

</Listing>

再次编译，我们得到了……不同的错误！编译器教会了我们很多。

```console
{{#include ../listings/ch16-fearless-concurrency/listing-16-14/output.txt}}
```

哇，这个错误信息非常冗长！以下是需要关注的重要部分：`` `Rc<Mutex<i32>>` 不能安全地在线程之间发送 ``。编译器还告诉我们原因：`` trait `Send` 没有为 `Rc<Mutex<i32>>` 实现 ``。我们将在下一节讨论 `Send`：它是确保我们与线程一起使用的类型适用于并发情况的 trait 之一。

不幸的是，`Rc<T>` 不能安全地跨线程共享。当 `Rc<T>` 管理引用计数时，它会在每次调用 `clone` 时增加计数，并在每个克隆被丢弃时减少计数。但它没有使用任何并发原语来确保对计数的更改不会被另一个线程中断。这可能导致错误的计数——微妙的错误，进而可能导致内存泄漏或在我们使用完值之前将其丢弃。我们需要的是一个与 `Rc<T>` 完全相同的类型，但它以线程安全的方式更改引用计数。

#### 使用 `Arc<T>` 进行原子引用计数

幸运的是，`Arc<T>` 是一个类似于 `Rc<T>` 的类型，可以在并发情况下安全使用。**a** 代表**原子**，意味着它是一个**原子引用计数**类型。原子是另一种并发原语，我们不会在这里详细讨论：有关更多详细信息，请参阅标准库文档中的 [`std::sync::atomic`][atomic]<!-- ignore -->。在这一点上，你只需要知道原子像原始类型一样工作，但可以安全地跨线程共享。

你可能会想知道为什么所有原始类型都不是原子的，以及为什么标准库类型默认不使用 `Arc<T>`。原因是线程安全会带来性能损失，你只在你真正需要时才愿意支付。如果你只是在一个线程内对值执行操作，如果你的代码不必强制执行原子提供的保证，它可以运行得更快。

让我们回到我们的示例：`Arc<T>` 和 `Rc<T>` 具有相同的 API，因此我们通过更改 `use` 行、`new` 调用和 `clone` 调用来修复我们的程序。Listing 16-15 中的代码最终将编译并运行。

<Listing number="16-15" file-name="src/main.rs" caption="使用 `Arc<T>` 包装 `Mutex<T>` 以便能够在多个线程之间共享所有权">

```rust
{{#rustdoc_include ../listings/ch16-fearless-concurrency/listing-16-15/src/main.rs}}
```

</Listing>

此代码将打印以下内容：

<!-- 不提取输出，因为对此输出的更改不显著；更改可能是由于线程运行方式不同，而不是编译器的更改 -->

```text
Result: 10
```

我们做到了！我们从 0 数到 10，这可能看起来不是很令人印象深刻，但它教会了我们很多关于 `Mutex<T>` 和线程安全的知识。你也可以使用此程序的结构来执行比仅仅递增计数器更复杂的操作。使用这种策略，你可以将计算分成独立的部分，将这些部分分配到线程中，然后使用 `Mutex<T>` 让每个线程用其部分更新最终结果。

请注意，如果你正在执行简单的数值操作，标准库的 [`std::sync::atomic` 模块][atomic]<!-- ignore --> 提供了比 `Mutex<T>` 更简单的类型。这些类型提供了对原始类型的安全、并发、原子访问。我们选择在此示例中使用 `Mutex<T>` 和原始类型，以便我们可以专注于 `Mutex<T>` 的工作原理。

### `RefCell<T>`/`Rc<T>` 和 `Mutex<T>`/`Arc<T>` 之间的相似之处

你可能已经注意到 `counter` 是不可变的，但我们可以获得对其内部值的可变引用；这意味着 `Mutex<T>` 提供了内部可变性，就像 `Cell` 系列一样。就像我们在第 15 章中使用 `RefCell<T>` 来允许我们在 `Rc<T>` 内部改变内容一样，我们使用 `Mutex<T>` 来改变 `Arc<T>` 内部的内容。

另一个需要注意的细节是，当你使用 `Mutex<T>` 时，Rust 无法保护你免受所有类型的逻辑错误。回想一下第 15 章，使用 `Rc<T>` 会带来创建引用循环的风险，其中两个 `Rc<T>` 值相互引用，导致内存泄漏。同样，`Mutex<T>` 会带来创建**死锁**的风险。当操作需要锁定两个资源并且两个线程各自获取了一个锁时，就会发生死锁，导致它们永远等待对方。如果你对死锁感兴趣，尝试创建一个有死锁的 Rust 程序；然后研究任何语言中互斥锁的死锁缓解策略，并尝试在 Rust 中实现它们。标准库 API 文档中的 `Mutex<T>` 和 `MutexGuard` 提供了有用的信息。

我们将在本章的最后讨论 `Send` 和 `Sync` trait，以及如何将它们与自定义类型一起使用。

[atomic]: ../std/sync/atomic/index.html